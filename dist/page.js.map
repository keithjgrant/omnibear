{"version":3,"sources":["webpack:///page.js","webpack:///webpack/bootstrap d1972d88dc8696679dab?cc4e*","webpack:///./src/page/entry.js","webpack:///./src/page/dom.js","webpack:///./~/microformat-shiv/microformat-shiv.js","webpack:///./src/page.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","125","_interopRequireDefault","obj","default","clearItem","currentItem","chrome","runtime","sendMessage","action","removeHighlight","classList","remove","CLASS_NAME","currentItemUrl","focusClickedEntry","e","entry","document","location","hostname","findTweet","target","findFacebookPost","findHEntry","payload","url","element","add","el","_dom","getAncestorNodeByClass","getAttribute","getAncestorNode","id","startsWith","timestamp","getElementsByClassName","tagName","parentElement","href","mf","_microformatShiv2","node","items","length","properties","getCurrentItemUrl","_microformatShiv","134","className","Array","isArray","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","cn","contains","err","return","filter","135","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","this","addV1","parser","options","maps","version","livingStandard","Parser","rootPrefix","propertyPrefixes","excludeTags","rels","init","rootNode","baseUrl","filters","textFormat","dateFormat","overlappingVersions","impliedPropertiesByVersion","parseLatLonGeo","lang","rootID","errors","noContentErr","out","formatEmpty","data","mergeOptions","getDOMContext","hasMicroformats","prepareDOM","newRootNode","findFilterNodes","walkRoot","domUtils","canCloneDocument","clearUpDom","findRels","push","formatError","getParent","getParentTreeWalk","count","classItems","x","findRootNodes","getAttributeList","utils","startWith","appendCount","key","indexOf","relCount","countRels","isMicroformat","classes","getTopMostNode","getUfClassNames","forEach","map","JSON","parse","stringify","recursive","parentNode","nodeName","nodes","baseTag","querySelector","path","newDocument","getNodePath","cloneDocument","getNodeByPath","addIncludes","rel-urls","isString","createNode","y","getMapping","v1Name","hasAttributeValue","clone","appendChild","shouldInclude","uf","type","includeRoot","arr","getNodesByAttribute","child","context","children","walkTree","concat","getChildren","itemRootID","createUfObject","typeVersion","walkChildren","impliedRules","getFirstAncestorAttribute","cleanUfObject","ufName","parentClasses","rootItem","propertyName","propertyVersion","z","addedAsRoot","text","removePropPrefix","impliedValueRule","getValue","hasRootID","isAllowedPropertyVersion","appendRootID","getPValue","getEValue","getUValue","getDTValue","valueParse","getValueClass","getValueTitle","getAttrValFromTagList","html","expandURLs","resolve","fromValue","format","dates","isDuration","isTime","times","parseAmPmTime","ISODate","toString","rootids","hasAttribute","setAttribute","join","propertyType","trim","parseText","concatFragments","getNodesByAttributeValue","hasHClass","ufNameArr","classNames","item","prop","propName","v2Name","impiedRel","hasTagName","split","isLowerCase","subTree","a","getV2RootName","findRelImpied","b","names","isOnlyWhiteSpace","altValue","microformat","prefix","substr","attrName","attr","removeRootIds","removeAttribute","removeIncludes","constructor","impliedBackwardComp","impliedhFeedTitle","impliedName","impliedPhoto","impliedUrl","impliedValue","impliedDate","impliedGeo","getImpliedProperty","getNameAttr","photo","getPhotoAttr","getURLAttr","newDate","dateTimeUnion","tagList","getAttrFunction","descendant","getSingleDescendantOfType","getSingleDescendant","getAltValue","parentPropertyName","title","textContent","geoPair","parts","longitude","latitude","valid","replace","parseFloat","isNumber","hasProperties","addAttributeIncludes","addClassIncludes","attributeName","idList","apppendInclude","include","getElementById","markIncludeChildren","removeChild","relList","resolved","relUrl","getRelProperties","media","hreflang","relAlt","hasRel","isNaN","isFinite","propertyIsEnumerable","isFunction","test","toLowerCase","replaceCharAt","index","character","trimWhitespace","collapseWhiteSpace","sortObjects","reverse","getDOMParser","DOMParser","Components","createInstance","interfaces","nsIDOMParser","domParser","parseFromString","nodeType","ownerDocument","innerText","innerHTML","attributeValue","docNode","selector","attList","querySelectorAll","tagNames","attrValue","getDescendant","onlyOfType","countAll","countOfType","childNode","newNode","cloneNode","removeDescendantsByTagName","getElementsByTagName","elements","getElementText","getOrderedAttributes","nodeStr","outerHTML","attrs","attributes","indexNum","sort","decodeEntities","doc","createTextNode","nodeValue","implementation","createHTMLDocument","importNode","documentElement","replaceChild","getChildIndex","parent","childNodes","createElement","createNodeWithText","_domParser","_html","_nodes","_baseNode","_linkNode","URL","URI","dateString","clear","setFormatSep","arguments","clearDate","clearTime","clearTimeZone","setAutoProfileState","dY","dM","dD","dDDD","tH","tM","tS","tD","tzH","tzM","tzPN","autoProfile","sep","dsep","tsep","tzsep","tzZulu","setFormat","tzArray","position","datePart","timePart","timeZonePart","toUpperCase","substring","parseDate","parseTime","parseTimeZone","match","timeString","toTimeString","output","hasFullDate","hasDate","hasTime","hasTimeZone","hasAM","hasPM","removeAMPM","parseInt","date","time","isodate","isotime","charAt","splitTimeAndZone","chars","slice","blockLevelTags","walkTreeForText","normalise","clonedNode","trimmedNode","formatText","j","selfClosingElt","walkTreeForHtml","containerNode","post-office-box","street-address","extended-address","locality","region","postal-code","country-name","fn","adr","agent","bday","class","category","email","geo","label","logo","mailer","honorific-prefix","given-name","additional-name","family-name","honorific-suffix","nickname","note","org","p-organization-name","p-organization-unit","rev","role","sequence","sort-string","sound","tel","tz","uid","entry-title","entry-summary","entry-content","published","updated","author","summary","dtstart","dtend","description","duration","contact","organizer","attendee","attach","status","rdate","rrule","lister","dtlisted","dtexpired","price","listing","source-org","dateline","item-license","principles","childStructure","organization-name","organization-unit","brand","review","identifier","ingredient","yield","instructions","nutrition","education","experience","skill","affiliation","rating","average","best","worst","votes","reviewer","dtreviewer","friend","acquaintance","met","co-worker","colleague","co-resident","neighbor","sibling","spouse","kin","muse","crush","sweetheart","me","license","nofollow","tag","self","bookmark","home","directory","enclosure","pronunciation","payment","External","DOMParser_proto","real_parseFromString","textHTML","textXML","htmlElInnerHTML","er","markup","doc_el","first_el","firstElementChild","childElementCount","localName","139","_entry","handleMessage","request","sender","sendResponse","handleTokenError","error","isAuthPage","heading","paragraph","pathname","sendFocusMessage","selectedEntry","body","addEventListener","onMessage","addListener","hidden","window"],"mappings":"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","file":"page.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 139);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 125:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearItem = clearItem;\nexports.removeHighlight = removeHighlight;\nexports.focusClickedEntry = focusClickedEntry;\nexports.getCurrentItemUrl = getCurrentItemUrl;\n\nvar _microformatShiv = __webpack_require__(135);\n\nvar _microformatShiv2 = _interopRequireDefault(_microformatShiv);\n\nvar _dom = __webpack_require__(134);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// TODO: replace this lib with a better mf parser, preferably\n// one that doesn't blow up while tests run in Node environment\nvar CLASS_NAME = '__omnibear-selected-item';\nvar currentItem = void 0;\nvar currentItemUrl = void 0;\n\nfunction clearItem() {\n  if (currentItem) {\n    chrome.runtime.sendMessage({\n      action: 'clear-entry'\n    });\n    removeHighlight();\n  }\n}\n\nfunction removeHighlight() {\n  if (currentItem) {\n    currentItem.classList.remove(CLASS_NAME);\n    currentItem = null;\n    currentItemUrl = null;\n  }\n}\n\nfunction focusClickedEntry(e) {\n  clearItem();\n  var entry = void 0;\n  if (document.location.hostname === 'twitter.com') {\n    entry = findTweet(e.target);\n  } else if (document.location.hostname === 'www.facebook.com') {\n    entry = findFacebookPost(e.target);\n  } else {\n    entry = findHEntry(e.target);\n  }\n\n  if (!entry) {\n    return;\n  }\n  chrome.runtime.sendMessage({\n    action: 'select-entry',\n    payload: { url: entry.url }\n  });\n  entry.element.classList.add(CLASS_NAME);\n  currentItem = entry.element;\n  currentItemUrl = entry.url;\n}\n\nfunction findTweet(el) {\n  var element = (0, _dom.getAncestorNodeByClass)(el, 'tweet');\n  if (!element) {\n    return false;\n  };\n  var url = 'https://twitter.com' + element.getAttribute('data-permalink-path');\n  return { element: element, url: url };\n}\n\nfunction findFacebookPost(el) {\n  var element = (0, _dom.getAncestorNode)(el, function (e) {\n    return e.id.startsWith('hyperfeed_story_id_');\n  });\n  if (!element) {\n    return false;\n  }\n\n  var timestamp = element.getElementsByClassName('timestampContent');\n  if (timestamp && timestamp[0]) {\n    timestamp = timestamp[0];\n    while (timestamp.tagName != 'A' && timestamp.tagName != 'BODY') {\n      timestamp = timestamp.parentElement;\n    }\n\n    var url = timestamp.href;\n    if (url) {\n      return { element: element, url: url };\n    }\n  }\n\n  return false;\n}\n\nfunction findHEntry(el) {\n  var element = (0, _dom.getAncestorNodeByClass)(el, 'h-entry');\n  if (!element) {\n    return false;\n  }\n  var mf = _microformatShiv2.default.get({ node: el });\n  var url = void 0;\n  if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n    url = mf.items[0].properties.url[0];\n  }\n  if (!url) {\n    if (element.tagName === 'BODY') {\n      return false;\n    } else {\n      return findHEntry(element.parentElement, 'h-entry');\n    }\n  }\n\n  return { element: element, url: url };\n}\n\nfunction getCurrentItemUrl() {\n  return currentItemUrl;\n}\n\n/***/ }),\n\n/***/ 134:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAncestorNodeByClass = getAncestorNodeByClass;\nexports.getAncestorNode = getAncestorNode;\nfunction getAncestorNodeByClass(element, className) {\n  if (!Array.isArray(className)) {\n    className = [className];\n  }\n  return getAncestorNode(element, function (el) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = className[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var cn = _step.value;\n\n        if (el.classList.contains(cn)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return false;\n  });\n}\n\nfunction getAncestorNode(el, filter) {\n  while (!filter(el) && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n  if (!filter(el)) {\n    // el is <body> (and doesn't match filter)\n    return null;\n  }\n  return el;\n}\n\n/***/ }),\n\n/***/ 135:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n/***/ }),\n\n/***/ 139:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _entry = __webpack_require__(125);\n\n(function () {\n\n  document.body.addEventListener('click', _entry.clearItem);\n\n  document.body.addEventListener('contextmenu', _entry.focusClickedEntry);\n\n  function handleMessage(request, sender, sendResponse) {\n    switch (request.action) {\n      case 'fetch-token-error':\n        handleTokenError(request.payload.error);\n        break;\n      // case 'remove-entry-highlight':\n      //   removeHighlight();\n      //   break;\n    }\n  }\n  chrome.runtime.onMessage.addListener(handleMessage);\n\n  if (!document.hidden) {\n    sendFocusMessage();\n  }\n  window.addEventListener('focus', sendFocusMessage);\n\n  function handleTokenError(error) {\n    if (!isAuthPage) {\n      return;\n    }\n\n    var heading = document.querySelector('.main > h1');\n    var paragraph = document.querySelector('.main > p');\n    heading.innerHTML = 'Error fetching token from token endpoint';\n    paragraph.innerHTML = error;\n  }\n\n  function isAuthPage() {\n    var l = document.location;\n    return l.hostname === 'omnibear.com' && l.pathname === '/auth/success/';\n  }\n\n  function sendFocusMessage() {\n    chrome.runtime.sendMessage({\n      action: 'focus-window',\n      payload: {\n        selectedEntry: (0, _entry.getCurrentItemUrl)()\n      }\n    });\n  }\n})();\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// page.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 139);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d1972d88dc8696679dab","// TODO: replace this lib with a better mf parser, preferably\n// one that doesn't blow up while tests run in Node environment\nimport microformat from 'microformat-shiv';\nimport {getAncestorNode, getAncestorNodeByClass} from './dom';\n\n\nconst CLASS_NAME = '__omnibear-selected-item';\nlet currentItem;\nlet currentItemUrl;\n\nexport function clearItem() {\n  if (currentItem) {\n    chrome.runtime.sendMessage({\n      action: 'clear-entry',\n    });\n    removeHighlight();\n  }\n}\n\nexport function removeHighlight() {\n  if (currentItem) {\n    currentItem.classList.remove(CLASS_NAME);\n    currentItem = null;\n    currentItemUrl = null;\n  }\n}\n\nexport function focusClickedEntry(e) {\n  clearItem();\n  let entry;\n  if (document.location.hostname === 'twitter.com') {\n    entry = findTweet(e.target);\n  } else if (document.location.hostname === 'www.facebook.com') {\n    entry = findFacebookPost(e.target);\n  } else {\n    entry = findHEntry(e.target);\n  }\n\n  if (!entry) {\n    return;\n  }\n  chrome.runtime.sendMessage({\n    action: 'select-entry',\n    payload: { url: entry.url },\n  });\n  entry.element.classList.add(CLASS_NAME);\n  currentItem = entry.element;\n  currentItemUrl = entry.url;\n}\n\nfunction findTweet(el) {\n  const element = getAncestorNodeByClass(el, 'tweet');\n  if (!element) { return false; };\n  const url = `https://twitter.com${element.getAttribute('data-permalink-path')}`;\n  return { element, url };\n}\n\nfunction findFacebookPost(el) {\n  const element = getAncestorNode(el, (e) => {\n    return e.id.startsWith('hyperfeed_story_id_');\n  });\n  if (!element) { return false; }\n\n  let timestamp = element.getElementsByClassName('timestampContent')\n  if (timestamp && timestamp[0]) {\n    timestamp = timestamp[0];\n    while(timestamp.tagName != 'A' && timestamp.tagName != 'BODY') {\n      timestamp = timestamp.parentElement;\n    }\n\n    const url = timestamp.href;\n    if (url) {\n      return { element, url };\n    }\n  }\n\n  return false;\n}\n\nfunction findHEntry(el) {\n  const element = getAncestorNodeByClass(el, 'h-entry');\n  if (!element) { return false; }\n  const mf = microformat.get({node: el});\n  let url;\n  if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n    url = mf.items[0].properties.url[0];\n  }\n  if (!url) {\n    if (element.tagName === 'BODY') {\n      return false;\n    } else {\n      return findHEntry(element.parentElement, 'h-entry');\n    }\n  }\n\n  return { element, url };\n}\n\nexport function getCurrentItemUrl() {\n  return currentItemUrl;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/page/entry.js","\nexport function getAncestorNodeByClass(element, className) {\n  if (!Array.isArray(className)) {\n    className = [className];\n  }\n  return getAncestorNode(element, (el) => {\n    for (let cn of className) {\n      if (el.classList.contains(cn)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport function getAncestorNode(el, filter) {\n  while(!filter(el) && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n  if (!filter(el)) {\n    // el is <body> (and doesn't match filter)\n    return null;\n  }\n  return el;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/page/dom.js","/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/microformat-shiv/microformat-shiv.js\n// module id = 135\n// module chunks = 2","import {clearItem, removeHighlight, focusClickedEntry, getCurrentItemUrl} from './page/entry';\n\n(function () {\n\n  document.body.addEventListener('click', clearItem);\n\n  document.body.addEventListener('contextmenu', focusClickedEntry);\n\n  function handleMessage(request, sender, sendResponse) {\n    switch (request.action) {\n      case 'fetch-token-error':\n        handleTokenError(request.payload.error);\n        break;\n      // case 'remove-entry-highlight':\n      //   removeHighlight();\n      //   break;\n    }\n  }\n  chrome.runtime.onMessage.addListener(handleMessage);\n\n  if (!document.hidden) {\n    sendFocusMessage();\n  }\n  window.addEventListener('focus', sendFocusMessage);\n\n  function handleTokenError(error) {\n    if (!isAuthPage) {\n      return;\n    }\n\n    const heading = document.querySelector('.main > h1');\n    const paragraph = document.querySelector('.main > p');\n    heading.innerHTML = 'Error fetching token from token endpoint';\n    paragraph.innerHTML = error;\n  }\n\n  function isAuthPage() {\n    const l = document.location;\n    return (l.hostname === 'omnibear.com' && l.pathname === '/auth/success/');\n  }\n\n  function sendFocusMessage() {\n    chrome.runtime.sendMessage({\n      action: 'focus-window',\n      payload: {\n        selectedEntry: getCurrentItemUrl(),\n      },\n    });\n  }\n}());\n\n\n\n// WEBPACK FOOTER //\n// ./src/page.js"],"sourceRoot":""}