{"version":3,"sources":["webpack:///page.js","webpack:///webpack/bootstrap 7cdb821dcd93ececc2a6?0ac7*","webpack:///./src/page/dom.js","webpack:///./~/microformat-shiv/microformat-shiv.js","webpack:///./src/page.js","webpack:///./src/page/entry.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","15","getAncestorNodeByClass","element","className","Array","isArray","getAncestorNode","el","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","cn","classList","contains","err","return","filter","tagName","parentElement","17","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","apply","this","addV1","parser","options","maps","add","version","livingStandard","Parser","rootPrefix","propertyPrefixes","excludeTags","rels","init","rootNode","document","baseUrl","filters","textFormat","dateFormat","overlappingVersions","impliedPropertiesByVersion","parseLatLonGeo","lang","rootID","errors","noContentErr","out","formatEmpty","data","mergeOptions","getDOMContext","hasMicroformats","prepareDOM","length","newRootNode","findFilterNodes","walkRoot","items","domUtils","canCloneDocument","clearUpDom","findRels","push","formatError","getParent","node","getParentTreeWalk","count","classItems","x","findRootNodes","getAttributeList","utils","startWith","appendCount","key","indexOf","relCount","countRels","isMicroformat","classes","getTopMostNode","getUfClassNames","forEach","map","properties","JSON","parse","stringify","recursive","parentNode","nodeName","nodes","baseTag","href","location","e","querySelector","getAttribute","path","newDocument","getNodePath","cloneDocument","getNodeByPath","addIncludes","rel-urls","isString","createNode","y","getMapping","v1Name","hasAttributeValue","clone","appendChild","shouldInclude","uf","type","includeRoot","arr","getNodesByAttribute","child","context","children","walkTree","concat","getChildren","obj","itemRootID","createUfObject","typeVersion","walkChildren","impliedRules","getFirstAncestorAttribute","cleanUfObject","ufName","parentClasses","rootItem","propertyName","propertyVersion","z","addedAsRoot","text","removePropPrefix","impliedValueRule","getValue","hasRootID","isAllowedPropertyVersion","appendRootID","getPValue","getEValue","getUValue","getDTValue","valueParse","getValueClass","getValueTitle","getAttrValFromTagList","html","expandURLs","url","resolve","fromValue","format","dates","isDuration","isTime","times","parseAmPmTime","ISODate","toString","id","rootids","hasAttribute","setAttribute","join","propertyType","trim","parseText","concatFragments","getNodesByAttributeValue","hasHClass","ufNameArr","classNames","item","prop","propName","v2Name","impiedRel","hasTagName","split","isLowerCase","subTree","a","getV2RootName","findRelImpied","b","names","isOnlyWhiteSpace","altValue","microformat","prefix","substr","attrName","attr","removeRootIds","removeAttribute","removeIncludes","constructor","impliedBackwardComp","impliedhFeedTitle","impliedName","impliedPhoto","impliedUrl","impliedValue","impliedDate","impliedGeo","getImpliedProperty","getNameAttr","photo","getPhotoAttr","getURLAttr","newDate","dateTimeUnion","tagList","getAttrFunction","descendant","getSingleDescendantOfType","getSingleDescendant","getAltValue","parentPropertyName","title","textContent","geoPair","parts","longitude","latitude","valid","replace","parseFloat","isNumber","hasProperties","addAttributeIncludes","addClassIncludes","attributeName","idList","apppendInclude","include","getElementById","markIncludeChildren","removeChild","relList","resolved","relUrl","getRelProperties","media","hreflang","relAlt","hasRel","isNaN","isFinite","propertyIsEnumerable","isFunction","test","toLowerCase","replaceCharAt","index","character","trimWhitespace","collapseWhiteSpace","sortObjects","reverse","getDOMParser","DOMParser","Components","createInstance","interfaces","nsIDOMParser","domParser","parseFromString","nodeType","ownerDocument","innerText","innerHTML","attributeValue","docNode","selector","attList","querySelectorAll","tagNames","attrValue","getDescendant","onlyOfType","countAll","countOfType","childNode","newNode","cloneNode","removeDescendantsByTagName","getElementsByTagName","elements","getElementText","getOrderedAttributes","nodeStr","outerHTML","attrs","attributes","indexNum","sort","decodeEntities","doc","createTextNode","nodeValue","implementation","createHTMLDocument","importNode","documentElement","replaceChild","getChildIndex","parent","childNodes","createElement","createNodeWithText","_domParser","_html","_nodes","_baseNode","_linkNode","URL","URI","dateString","clear","setFormatSep","arguments","clearDate","clearTime","clearTimeZone","setAutoProfileState","dY","dM","dD","dDDD","tH","tM","tS","tD","tzH","tzM","tzPN","autoProfile","sep","dsep","tsep","tzsep","tzZulu","setFormat","tzArray","position","datePart","timePart","timeZonePart","toUpperCase","substring","parseDate","parseTime","parseTimeZone","match","timeString","toTimeString","output","hasFullDate","hasDate","hasTime","hasTimeZone","hasAM","hasPM","removeAMPM","parseInt","date","time","isodate","isotime","charAt","splitTimeAndZone","chars","slice","blockLevelTags","walkTreeForText","normalise","clonedNode","trimmedNode","formatText","j","selfClosingElt","walkTreeForHtml","containerNode","post-office-box","street-address","extended-address","locality","region","postal-code","country-name","fn","adr","agent","bday","class","category","email","geo","label","logo","mailer","honorific-prefix","given-name","additional-name","family-name","honorific-suffix","nickname","note","org","p-organization-name","p-organization-unit","rev","role","sequence","sort-string","sound","tel","tz","uid","entry-title","entry-summary","entry-content","published","updated","author","summary","dtstart","dtend","description","duration","contact","organizer","attendee","attach","status","rdate","rrule","lister","dtlisted","dtexpired","price","listing","entry","source-org","dateline","item-license","principles","childStructure","organization-name","organization-unit","brand","review","identifier","ingredient","yield","instructions","nutrition","education","experience","skill","affiliation","rating","average","best","worst","votes","reviewer","dtreviewer","friend","acquaintance","met","co-worker","colleague","co-resident","neighbor","sibling","spouse","kin","muse","crush","sweetheart","me","license","nofollow","tag","self","bookmark","home","directory","enclosure","pronunciation","payment","External","DOMParser_proto","real_parseFromString","textHTML","textXML","htmlElInnerHTML","er","markup","doc_el","first_el","firstElementChild","childElementCount","localName","21","_entry","handleMessage","request","sender","sendResponse","action","handleTokenError","payload","error","isAuthPage","heading","paragraph","hostname","pathname","sendFocusMessage","chrome","runtime","sendMessage","selectedEntry","getCurrentItemUrl","body","addEventListener","clearItem","focusClickedEntry","onMessage","addListener","hidden","window","6","_interopRequireDefault","default","currentItem","removeHighlight","remove","CLASS_NAME","currentItemUrl","findTweet","target","findFacebookPost","findHEntry","_dom","startsWith","timestamp","getElementsByClassName","mf","_microformatShiv2","_microformatShiv"],"mappings":"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","file":"page.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 15:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAncestorNodeByClass = getAncestorNodeByClass;\nexports.getAncestorNode = getAncestorNode;\nfunction getAncestorNodeByClass(element, className) {\n  if (!Array.isArray(className)) {\n    className = [className];\n  }\n  return getAncestorNode(element, function (el) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = className[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var cn = _step.value;\n\n        if (el.classList.contains(cn)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return false;\n  });\n}\n\nfunction getAncestorNode(el, filter) {\n  while (!filter(el) && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n  if (!filter(el)) {\n    // el is <body> (and doesn't match filter)\n    return null;\n  }\n  return el;\n}\n\n/***/ }),\n\n/***/ 17:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n/***/ }),\n\n/***/ 21:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _entry = __webpack_require__(6);\n\n(function () {\n\n  document.body.addEventListener('click', _entry.clearItem);\n\n  document.body.addEventListener('contextmenu', _entry.focusClickedEntry);\n\n  function handleMessage(request, sender, sendResponse) {\n    switch (request.action) {\n      case 'fetch-token-error':\n        handleTokenError(request.payload.error);\n        break;\n      // case 'remove-entry-highlight':\n      //   removeHighlight();\n      //   break;\n    }\n  }\n  chrome.runtime.onMessage.addListener(handleMessage);\n\n  if (!document.hidden) {\n    sendFocusMessage();\n  }\n  window.addEventListener('focus', sendFocusMessage);\n\n  function handleTokenError(error) {\n    if (!isAuthPage) {\n      return;\n    }\n\n    var heading = document.querySelector('.main > h1');\n    var paragraph = document.querySelector('.main > p');\n    heading.innerHTML = 'Error fetching token from token endpoint';\n    paragraph.innerHTML = error;\n  }\n\n  function isAuthPage() {\n    var l = document.location;\n    return l.hostname === 'omnibear.com' && l.pathname === '/auth/success/';\n  }\n\n  function sendFocusMessage() {\n    chrome.runtime.sendMessage({\n      action: 'focus-window',\n      payload: {\n        selectedEntry: (0, _entry.getCurrentItemUrl)()\n      }\n    });\n  }\n})();\n\n/***/ }),\n\n/***/ 6:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearItem = clearItem;\nexports.removeHighlight = removeHighlight;\nexports.focusClickedEntry = focusClickedEntry;\nexports.getCurrentItemUrl = getCurrentItemUrl;\n\nvar _microformatShiv = __webpack_require__(17);\n\nvar _microformatShiv2 = _interopRequireDefault(_microformatShiv);\n\nvar _dom = __webpack_require__(15);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// TODO: replace this lib with a better mf parser, preferably\n// one that doesn't blow up while tests run in Node environment\nvar CLASS_NAME = '__omnibear-selected-item';\nvar currentItem = void 0;\nvar currentItemUrl = void 0;\n\nfunction clearItem() {\n  if (currentItem) {\n    chrome.runtime.sendMessage({\n      action: 'clear-entry'\n    });\n    removeHighlight();\n  }\n}\n\nfunction removeHighlight() {\n  if (currentItem) {\n    currentItem.classList.remove(CLASS_NAME);\n    currentItem = null;\n    currentItemUrl = null;\n  }\n}\n\nfunction focusClickedEntry(e) {\n  clearItem();\n  var entry = void 0;\n  if (document.location.hostname === 'twitter.com') {\n    entry = findTweet(e.target);\n  } else if (document.location.hostname === 'www.facebook.com') {\n    entry = findFacebookPost(e.target);\n  } else {\n    entry = findHEntry(e.target);\n  }\n\n  if (!entry) {\n    return;\n  }\n  chrome.runtime.sendMessage({\n    action: 'select-entry',\n    payload: { url: entry.url }\n  });\n  entry.element.classList.add(CLASS_NAME);\n  currentItem = entry.element;\n  currentItemUrl = entry.url;\n}\n\nfunction findTweet(el) {\n  var element = (0, _dom.getAncestorNodeByClass)(el, 'tweet');\n  if (!element) {\n    return false;\n  };\n  var url = 'https://twitter.com' + element.getAttribute('data-permalink-path');\n  return { element: element, url: url };\n}\n\nfunction findFacebookPost(el) {\n  var element = (0, _dom.getAncestorNode)(el, function (e) {\n    return e.id.startsWith('hyperfeed_story_id_');\n  });\n  if (!element) {\n    return false;\n  }\n\n  var timestamp = element.getElementsByClassName('timestampContent');\n  if (timestamp && timestamp[0]) {\n    timestamp = timestamp[0];\n    while (timestamp.tagName != 'A' && timestamp.tagName != 'BODY') {\n      timestamp = timestamp.parentElement;\n    }\n\n    var url = timestamp.href;\n    if (url) {\n      return { element: element, url: url };\n    }\n  }\n\n  return {};\n}\n\nfunction findHEntry(el) {\n  var element = (0, _dom.getAncestorNodeByClass)(el, 'h-entry');\n  if (!element) {\n    return false;\n  }\n  var mf = _microformatShiv2.default.get({ node: el });\n  var url = void 0;\n  if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n    url = mf.items[0].properties.url[0];\n  }\n\n  return { element: element, url: url };\n}\n\nfunction getCurrentItemUrl() {\n  return currentItemUrl;\n}\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// page.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7cdb821dcd93ececc2a6","\nexport function getAncestorNodeByClass(element, className) {\n  if (!Array.isArray(className)) {\n    className = [className];\n  }\n  return getAncestorNode(element, (el) => {\n    for (let cn of className) {\n      if (el.classList.contains(cn)) {\n        return true;\n      }\n    }\n    return false;\n  });\n}\n\nexport function getAncestorNode(el, filter) {\n  while(!filter(el) && el.tagName != 'BODY') {\n    el = el.parentElement;\n  }\n  if (!filter(el)) {\n    // el is <body> (and doesn't match filter)\n    return null;\n  }\n  return el;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/page/dom.js","/*\n   microformat-shiv - v2.0.2\n   Built: 2016-10-26 10:10 - http://microformat-shiv.com\n   Copyright (c) 2016 Glenn Jones\n   Licensed MIT \n*/\n\n\nvar Microformats; // jshint ignore:line\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define([], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.Microformats = factory();\n  }\n}(this, function () {\n    \n    var modules = {};\n    \n\n\tmodules.version = '2.0.2';\n\tmodules.livingStandard = '2016-05-25T09:22:18Z';\n\n\t/**\n\t * constructor\n\t *\n\t */\n\tmodules.Parser = function () {\n\t\tthis.rootPrefix = 'h-';\n\t\tthis.propertyPrefixes = ['p-', 'dt-', 'u-', 'e-'];\n\t\tthis.excludeTags = ['br', 'hr'];\n\t};\n\n\n\t// create objects incase the v1 map modules don't load\n\tmodules.maps = (modules.maps)? modules.maps : {};\n\tmodules.rels = (modules.rels)? modules.rels : {};\n\n\n\tmodules.Parser.prototype = {\n\n\t\tinit: function(){\n\t\t\tthis.rootNode = null;\n\t\t\tthis.document = null;\n\t\t\tthis.options = {\n\t\t\t\t'baseUrl': '',\n\t\t\t\t'filters': [],\n\t\t\t\t'textFormat': 'whitespacetrimmed',\n\t\t\t\t'dateFormat': 'auto', // microformat2 for testing\n\t\t\t\t'overlappingVersions': false,\n\t\t\t\t'impliedPropertiesByVersion': true,\n\t\t\t\t'parseLatLonGeo': false,\n\t\t\t\t'lang': false\n\t\t\t};\n\t\t\tthis.rootID = 0;\n\t\t\tthis.errors = [];\n\t\t\tthis.noContentErr = 'No options.node or options.html was provided and no document object could be found.';\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse function\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tget: function(options) {\n\t\t\tvar out = this.formatEmpty(),\n\t\t\t\tdata = [],\n\t\t\t\trels;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.mergeOptions(options);\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t}else{\n\n\t\t\t\t// only parse h-* microformats if we need to\n\t\t\t\t// this is added to speed up parsing\n\t\t\t\tif(this.hasMicroformats(this.rootNode, options)){\n\t\t\t\t\tthis.prepareDOM( options );\n\n\t\t\t\t\tif(this.options.filters.length > 0){\n\t\t\t\t\t\t// parse flat list of items\n\t\t\t\t\t\tvar newRootNode = this.findFilterNodes(this.rootNode, this.options.filters);\n\t\t\t\t\t\tdata = this.walkRoot(newRootNode);\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// parse whole document from root\n\t\t\t\t\t\tdata = this.walkRoot(this.rootNode);\n\t\t\t\t\t}\n\n\t\t\t\t\tout.items = data;\n\t\t\t\t\t// don't clear-up DOM if it was cloned\n\t\t\t\t\tif(modules.domUtils.canCloneDocument(this.document) === false){\n\t\t\t\t\t\tthis.clearUpDom(this.rootNode);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// find any rels\n\t\t\t\tif(this.findRels){\n\t\t\t\t\trels = this.findRels(this.rootNode);\n\t\t\t\t\tout.rels = rels.rels;\n\t\t\t\t\tout['rel-urls'] = rels['rel-urls'];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(this.errors.length > 0){\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * parse to get parent microformat of passed node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @return {Object}\n\t\t */\n\t\tgetParent: function(node, options) {\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\n\t\t\tif(node){\n\t\t\t\treturn this.getParentTreeWalk(node, options);\n\t\t\t}else{\n\t\t\t\tthis.errors.push(this.noContentErr);\n\t\t\t\treturn this.formatError();\n\t\t\t}\n\t\t},\n\n\n\t    /**\n\t\t * get the count of microformats\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @return {Int}\n\t\t */\n\t\tcount: function( options ) {\n\t\t\tvar out = {},\n\t\t\t\titems,\n\t\t\t\tclassItems,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tthis.init();\n\t\t\toptions = (options)? options : {};\n\t\t\tthis.getDOMContext( options );\n\n\t\t\t// if we do not have any context create error\n\t\t\tif(!this.rootNode || !this.document){\n\t\t\t\treturn {'errors': [this.noContentErr]};\n\t\t\t}else{\n\n\t\t\t\titems = this.findRootNodes( this.rootNode, true );\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tclassItems = modules.domUtils.getAttributeList(items[i], 'class');\n\t\t\t\t\tx = classItems.length;\n\t\t\t\t\twhile(x--) {\n\t\t\t\t\t\t// find v2 names\n\t\t\t\t\t\tif(modules.utils.startWith( classItems[x], 'h-' )){\n\t\t\t\t\t\t\tthis.appendCount(classItems[x], 1, out);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// find v1 names\n\t\t\t\t\t\tfor(var key in modules.maps) {\n\t\t\t\t\t\t\t// dont double count if v1 and v2 roots are present\n\t\t\t\t\t\t\tif(modules.maps[key].root === classItems[x] && classItems.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\tthis.appendCount(key, 1, out);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar relCount = this.countRels( this.rootNode );\n\t\t\t\tif(relCount > 0){\n\t\t\t\t\tout.rels = relCount;\n\t\t\t\t}\n\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node have a class that marks it as a microformats root\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tisMicroformat: function( node, options ) {\n\t\t\tvar classes,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if documemt gets topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// look for h-* microformats\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = options.filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(classes.root.indexOf(options.filters[i]) > -1){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (classes.root.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a node or its children have microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Objecte} options\n\t\t * @return {Boolean}\n\t\t */\n\t\thasMicroformats: function( node, options ) {\n\t\t\tvar items,\n\t\t\t\ti;\n\n\t\t\tif(!node){\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// if browser based documemt get topmost node\n\t\t\tnode = modules.domUtils.getTopMostNode( node );\n\n\t\t\t// returns all microformat roots\n\t\t\titems = this.findRootNodes( node, true );\n\t\t\tif(options && options.filters && modules.utils.isArray(options.filters)){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif( this.isMicroformat( items[i], options ) ){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}else{\n\t\t\t\treturn (items.length > 0);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * add a new v1 mapping object to parser\n\t\t *\n\t\t * @param  {Array} maps\n\t\t */\n\t\tadd: function( maps ){\n\t\t\tmaps.forEach(function(map){\n\t\t\t\tif(map && map.root && map.name && map.properties){\n\t\t\t\tmodules.maps[map.name] = JSON.parse(JSON.stringify(map));\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\n\t\t/**\n\t\t * internal parse to get parent microformats by walking up the tree\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} options\n\t\t * @param  {Int} recursive\n\t\t * @return {Object}\n\t\t */\n\t\tgetParentTreeWalk: function (node, options, recursive) {\n\t\t\toptions = (options)? options : {};\n\n\t\t\t// recursive calls\n\t\t    if (recursive === undefined) {\n\t\t        if (node.parentNode && node.nodeName !== 'HTML'){\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t\t\t}else{\n\t\t            return this.formatEmpty();\n\t\t\t\t}\n\t\t    }\n\t\t    if (node !== null && node !== undefined && node.parentNode) {\n\t\t        if (this.isMicroformat( node, options )) {\n\t\t\t\t\t// if we have a match return microformat\n\t\t\t\t\toptions.node = node;\n\t\t            return this.get( options );\n\t\t        }else{\n\t\t            return this.getParentTreeWalk(node.parentNode, options, true);\n\t\t        }\n\t\t    }else{\n\t\t        return this.formatEmpty();\n\t\t    }\n\t\t},\n\n\n\n\t\t/**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tgetDOMContext: function( options ){\n\t\t\tvar nodes = modules.domUtils.getDOMContext( options );\n\t\t\tthis.rootNode = nodes.rootNode;\n\t\t\tthis.document = nodes.document;\n\t\t},\n\n\n\t\t/**\n\t\t * prepares DOM before the parse begins\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {Boolean}\n\t\t */\n\t\tprepareDOM: function( options ){\n\t\t\tvar baseTag,\n\t\t\t\thref;\n\n            // use current document to define baseUrl, try/catch needed for IE10+ error\n            try {\n                if (!options.baseUrl && this.document && this.document.location) {\n                    this.options.baseUrl = this.document.location.href;\n                }\n            } catch (e) {\n                // there is no alt action\n            }\n\n\n\t\t\t// find base tag to set baseUrl\n\t\t\tbaseTag = modules.domUtils.querySelector(this.document,'base');\n\t\t\tif(baseTag) {\n\t\t\t\thref = modules.domUtils.getAttribute(baseTag, 'href');\n\t\t\t\tif(href){\n\t\t\t\t\tthis.options.baseUrl = href;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get path to rootNode\n\t\t\t// then clone document\n\t\t\t// then reset the rootNode to its cloned version in a new document\n\t\t\tvar path,\n\t\t\t\tnewDocument,\n\t\t\t\tnewRootNode;\n\n\t\t\tpath = modules.domUtils.getNodePath(this.rootNode);\n\t\t\tnewDocument = modules.domUtils.cloneDocument(this.document);\n\t\t\tnewRootNode = modules.domUtils.getNodeByPath(newDocument, path);\n\n\t\t\t// check results as early IE fails\n\t\t\tif(newDocument && newRootNode){\n\t\t\t\tthis.document = newDocument;\n\t\t\t\tthis.rootNode = newRootNode;\n\t\t\t}\n\n\t\t\t// add includes\n\t\t\tif(this.addIncludes){\n\t\t\t\tthis.addIncludes( this.document );\n\t\t\t}\n\n\t\t\treturn (this.rootNode && this.document);\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure with errors\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatError: function(){\n\t\t\tvar out = this.formatEmpty();\n\t\t\tout.errors = this.errors;\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * returns an empty structure\n\t\t *\n\t\t *   @return {Object}\n\t\t */\n\t\tformatEmpty: function(){\n\t\t\treturn {\n\t\t\t    'items': [],\n\t\t\t    'rels': {},\n\t\t\t    'rel-urls': {}\n\t\t\t};\n\t\t},\n\n\n\t\t// find microformats of a given type and return node structures\n\t\tfindFilterNodes: function(rootNode, filters) {\n            if(modules.utils.isString(filters)){\n                filters = [filters];\n            }\n\t\t\tvar newRootNode = modules.domUtils.createNode('div'),\n\t\t\t\titems = this.findRootNodes(rootNode, true),\n\t\t\t\ti = 0,\n\t\t\t\tx = 0,\n\t\t\t\ty = 0;\n\n            // add v1 names\n            y = filters.length;\n            while (y--) {\n                if(this.getMapping(filters[y])){\n                    var v1Name = this.getMapping(filters[y]).root;\n                    filters.push(v1Name);\n                }\n            }\n\n\t\t\tif(items){\n\t\t\t\ti = items.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\t// append matching nodes into newRootNode\n\t\t\t\t\ty = filters.length;\n\t\t\t\t\twhile (y--) {\n\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(items[x], 'class', filters[y])){\n\t\t\t\t\t\t\tvar clone = modules.domUtils.clone(items[x]);\n\t\t\t\t\t\t\tmodules.domUtils.appendChild(newRootNode, clone);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn newRootNode;\n\t\t},\n\n\n\t\t/**\n\t\t * appends data to output object for count\n\t\t *\n\t\t * @param  {string} name\n\t\t * @param  {Int} count\n\t\t * @param  {Object}\n\t\t */\n\t\tappendCount: function(name, count, out){\n\t\t\tif(out[name]){\n\t\t\t\tout[name] = out[name] + count;\n\t\t\t}else{\n\t\t\t\tout[name] = count;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * is the microformats type in the filter list\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {Array} filters\n\t\t * @return {Boolean}\n\t\t */\n\t\tshouldInclude: function(uf, filters) {\n\t\t\tvar i;\n\n\t\t\tif(modules.utils.isArray(filters) && filters.length > 0) {\n\t\t\t\ti = filters.length;\n\t\t\t\twhile(i--) {\n\t\t\t\t\tif(uf.type[0] === filters[i]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * finds all microformat roots in a rootNode\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Boolean} includeRoot\n\t\t * @return {Array}\n\t\t */\n\t\tfindRootNodes: function(rootNode, includeRoot) {\n\t\t\tvar arr = null,\n\t\t\t\tout = [],\n\t\t\t\tclassList = [],\n\t\t\t\titems,\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tkey;\n\n\n\t\t\t// build an array of v1 root names\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif (modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\tclassList.push(modules.maps[key].root);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get all elements that have a class attribute\n\t\t\tincludeRoot = (includeRoot) ? includeRoot : false;\n\t\t\tif(includeRoot && rootNode.parentNode) {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode.parentNode, 'class');\n\t\t\t} else {\n\t\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'class');\n\t\t\t}\n\n\t\t\t// loop elements that have a class attribute\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\n\t\t\t\titems = modules.domUtils.getAttributeList(arr[x], 'class');\n\n\t\t\t\t// loop classes on an element\n\t\t\t\ty = items.length;\n\t\t\t\twhile(y--) {\n\t\t\t\t\t// match v1 root names\n\t\t\t\t\tif(classList.indexOf(items[y]) > -1) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// match v2 root name prefix\n\t\t\t\t\tif(modules.utils.startWith(items[y], 'h-')) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walk to find microformats\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkRoot: function(node){\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tchild,\n\t\t\t\tclasses,\n\t\t\t\titems = [],\n\t\t\t\tout = [];\n\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\t// if it is a root microformat node\n\t\t\tif(classes && classes.root.length > 0){\n\t\t\t\titems = this.walkTree(node);\n\n\t\t\t\tif(items.length > 0){\n\t\t\t\t\tout = out.concat(items);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t// check if there are children and one of the children has a root microformat\n\t\t\t\tchildren = modules.domUtils.getChildren( node );\n\t\t\t\tif(children && children.length > 0 && this.findRootNodes(node, true).length > -1){\n\t\t\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\t\t\tchild = children[i];\n\t\t\t\t\t\titems = context.walkRoot(child);\n\t\t\t\t\t\tif(items.length > 0){\n\t\t\t\t\t\t\tout = out.concat(items);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * starts the tree walking for a single microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\twalkTree: function(node) {\n\t\t\tvar classes,\n\t\t\t\tout = [],\n\t\t\t\tobj,\n\t\t\t\titemRootID;\n\n\t\t\t// loop roots found on one element\n\t\t\tclasses = this.getUfClassNames(node);\n\t\t\tif(classes && classes.root.length && classes.root.length > 0){\n\n\t\t\t\tthis.rootID++;\n\t\t\t\titemRootID = this.rootID;\n\t\t\t\tobj = this.createUfObject(classes.root, classes.typeVersion);\n\n\t\t\t\tthis.walkChildren(node, obj, classes.root, itemRootID, classes);\n\t\t\t\tif(this.impliedRules){\n\t\t\t\t\tthis.impliedRules(node, obj, classes);\n\t\t\t\t}\n\n\t\t\t\tif(this.options.lang === true){\n\t\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\t\tif(lang){\n\t\t\t\t\t\tobj.lang = lang;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tout.push( this.cleanUfObject(obj) );\n\n\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * finds child properties of microformat\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} out\n\t\t * @param  {String} ufName\n\t\t * @param  {Int} rootID\n\t\t * @param  {Object} parentClasses\n\t\t */\n\t\twalkChildren: function(node, out, ufName, rootID, parentClasses) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\trootItem,\n\t\t\t\titemRootID,\n\t\t\t\tvalue,\n\t\t\t\tpropertyName,\n\t\t\t\tpropertyVersion,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\tchild;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\ty = 0;\n\t\t\tz = children.length;\n\t\t\twhile(y < z) {\n\t\t\t\tchild = children[y];\n\n\t\t\t\t// get microformat classes for this single element\n\t\t\t\tvar classes = context.getUfClassNames(child, ufName);\n\n\t\t\t\t// a property which is a microformat\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length > 0 && !child.addedAsRoot) {\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[0][0]);\n\n\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[0][0], value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\tout.properties[propertyName].push(rootItem);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout.properties[propertyName] = [rootItem];\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t// used to stop duplication in heavily nested structures\n\t\t\t\t\tchild.addedAsRoot = true;\n\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cleanUfObject(rootItem);\n\n\t\t\t\t}\n\n\t\t\t\t// a property which is NOT a microformat and has not been used for a given root element\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length > 0) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = classes.properties.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\tvalue = context.getValue(child, classes.properties[x][0], out);\n\t\t\t\t\t\tpropertyName = context.removePropPrefix(classes.properties[x][0]);\n\t\t\t\t\t\tpropertyVersion = classes.properties[x][1];\n\n\t\t\t\t\t\t// modifies value with \"implied value rule\"\n\t\t\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\t\t\tif(context.impliedValueRule){\n\t\t\t\t\t\t\t\tout = context.impliedValueRule(out, parentClasses.properties[0][0], classes.properties[x][0], value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if we have not added this value into a property with the same name already\n\t\t\t\t\t\tif(!context.hasRootID(child, rootID, propertyName)) {\n\t\t\t\t\t\t\t// check the root and property is the same version or if overlapping versions are allowed\n\t\t\t\t\t\t\tif( context.isAllowedPropertyVersion( out.typeVersion, propertyVersion ) ){\n\t\t\t\t\t\t\t\t// add the property as an array of properties\n\t\t\t\t\t\t\t\tif(out.properties[propertyName]) {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName].push(value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tout.properties[propertyName] = [value];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// add rootid to node so we can track its use\n\t\t\t\t\t\t\t\tcontext.appendRootID(child, rootID, propertyName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node has no microformat classes, see if its children have\n\t\t\t\tif(classes.root.length === 0 && classes.properties.length === 0) {\n\t\t\t\t\tcontext.walkChildren(child, out, ufName, rootID, classes);\n\t\t\t\t}\n\n\t\t\t\t// if the node is a child root add it to the children tree\n\t\t\t\tif(classes.root.length > 0 && classes.properties.length === 0) {\n\n\t\t\t\t\t// create object with type, property and value\n\t\t\t\t\trootItem = context.createUfObject(\n\t\t\t\t\t\tclasses.root,\n\t\t\t\t\t\tclasses.typeVersion,\n\t\t\t\t\t\tmodules.text.parse(this.document, child, context.options.textFormat)\n\t\t\t\t\t);\n\n\t\t\t\t\t// add the microformat as an array of properties\n\t\t\t\t\tif(!out.children){\n\t\t\t\t\t\tout.children =  [];\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!context.hasRootID(child, rootID, 'child-root')) {\n\t\t\t\t\t\tout.children.push( rootItem );\n\t\t\t\t\t\tcontext.appendRootID(child, rootID, 'child-root');\n\t\t\t\t\t\tcontext.rootID++;\n\t\t\t\t\t}\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = rootItem.type.length;\n\t\t\t\t\titemRootID = context.rootID;\n\t\t\t\t\twhile(x < i) {\n\t\t\t\t\t\tcontext.walkChildren(child, rootItem, rootItem.type, itemRootID, classes);\n\t\t\t\t\t\tx++;\n\t\t\t\t\t}\n\t\t\t\t\tif(this.impliedRules){\n\t\t\t\t\t\tcontext.impliedRules(child, rootItem, classes);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.cleanUfObject( rootItem );\n\n\t\t\t\t}\n\n\n\n\t\t\t\ty++;\n\t\t\t}\n\n\t\t},\n\n\n\n\n\t\t/**\n\t\t * gets the value of a property from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @return {String || Object}\n\t\t */\n\t\tgetValue: function(node, className, uf) {\n\t\t\tvar value = '';\n\n\t\t\tif(modules.utils.startWith(className, 'p-')) {\n\t\t\t\tvalue = this.getPValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'e-')) {\n\t\t\t\tvalue = this.getEValue(node);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'u-')) {\n\t\t\t\tvalue = this.getUValue(node, true);\n\t\t\t}\n\n\t\t\tif(modules.utils.startWith(className, 'dt-')) {\n\t\t\t\tvalue = this.getDTValue(node, className, uf, true);\n\t\t\t}\n\t\t\treturn value;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains a 'p-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetPValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'p');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(node.name === 'br' || node.name === 'hr') {\n\t\t\t\tout = '';\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img', 'area'], 'alt');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'e-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Object}\n\t\t */\n\t\tgetEValue: function(node) {\n\n\t\t\tvar out = {value: '', html: ''};\n\n\t\t\tthis.expandURLs(node, 'src', this.options.baseUrl);\n\t\t\tthis.expandURLs(node, 'href', this.options.baseUrl);\n\n\t\t\tout.value = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\tout.html = modules.html.parse(node);\n\n\t\t\tif(this.options.lang === true){\n\t\t\t\tvar lang = modules.domUtils.getFirstAncestorAttribute(node, 'lang');\n\t\t\t\tif(lang){\n\t\t\t\t\tout.lang = lang;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'u-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetUValue: function(node, valueParse) {\n\t\t\tvar out = '';\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'u');\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['a', 'area'], 'href');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['img','audio','video','source'], 'src');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['video'], 'poster');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\n\t\t\t// if we have no protocol separator, turn relative url to absolute url\n\t\t\tif(out && out !== '' && out.indexOf('://') === -1) {\n\t\t\t\tout = modules.url.resolve(out, this.options.baseUrl);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data','input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\treturn(out) ? out : '';\n\t\t},\n\n\n\t\t/**\n\t\t * gets the value of a node which contains the 'dt-' property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} className\n\t\t * @param  {Object} uf\n\t\t * @param  {Boolean} valueParse\n\t\t * @return {String}\n\t\t */\n\t\tgetDTValue: function(node, className, uf, valueParse) {\n\t\t\tvar out = '',\n\t\t\t\tfromValue = false;\n\n\t\t\tif(valueParse) {\n\t\t\t\tout = this.getValueClass(node, 'dt');\n\t\t\t\tif(out){\n\t\t\t\t\tfromValue = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!out && valueParse) {\n\t\t\t\tout = this.getValueTitle(node);\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['time', 'ins', 'del'], 'datetime');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.domUtils.getAttrValFromTagList(node, ['data', 'input'], 'value');\n\t\t\t}\n\n\t\t\tif(!out) {\n\t\t\t\tout = modules.text.parse(this.document, node, this.options.textFormat);\n\t\t\t}\n\n\t\t\tif(out) {\n\t\t\t\tvar format = (fromValue)? 'microformat2' : this.options.dateFormat;\n\t\t\t\tif(modules.dates.isDuration(out)) {\n\t\t\t\t\t// just duration\n\t\t\t\t\treturn out;\n\t\t\t\t} else if(modules.dates.isTime(out)) {\n\t\t\t\t\t// just time or time+timezone\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.times.push([className, modules.dates.parseAmPmTime(out, format)]);\n\t\t\t\t\t}\n\t\t\t\t\treturn modules.dates.parseAmPmTime(out, format);\n\t\t\t\t} else {\n\t\t\t\t\t// returns a date - microformat profile\n\t\t\t\t\tif(uf) {\n\t\t\t\t\t\tuf.dates.push([className, new modules.ISODate(out).toString( format )]);\n\t\t\t\t\t}\n\t\t\t\t\treturn new modules.ISODate(out).toString( format );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * appends a new rootid to a given node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t */\n\t\tappendRootID: function(node, id, propertyName) {\n\t\t\tif(this.hasRootID(node, id, propertyName) === false){\n\t\t\t\tvar rootids = [];\n\t\t\t\tif(modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\t\trootids = modules.domUtils.getAttributeList(node,'rootids');\n\t\t\t\t}\n\t\t\t\trootids.push('id' + id + '-' + propertyName);\n\t\t\t\tmodules.domUtils.setAttribute(node, 'rootids', rootids.join(' '));\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does a given node already have a rootid\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} id\n\t\t * @param  {String} propertyName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasRootID: function(node, id, propertyName) {\n\t\t\tvar rootids = [];\n\t\t\tif(!modules.domUtils.hasAttribute(node,'rootids')){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\trootids = modules.domUtils.getAttributeList(node, 'rootids');\n\t\t\t\treturn (rootids.indexOf('id' + id + '-' + propertyName) > -1);\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * gets the text of any child nodes with a class value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} propertyName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetValueClass: function(node, propertyType) {\n\t\t\tvar context = this,\n\t\t\t\tchildren = [],\n\t\t\t\tout = [],\n\t\t\t\tchild,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\tchildren = modules.domUtils.getChildren( node );\n\n\t\t\tx = 0;\n\t\t\ti = children.length;\n\t\t\twhile(x < i) {\n\t\t\t\tchild = children[x];\n\t\t\t\tvar value = null;\n\t\t\t\tif(modules.domUtils.hasAttributeValue(child, 'class', 'value')) {\n\t\t\t\t\tswitch(propertyType) {\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tvalue = context.getPValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\t\tvalue = context.getUValue(child, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'dt':\n\t\t\t\t\t\tvalue = context.getDTValue(child, '', null, false);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(value) {\n\t\t\t\t\t\tout.push(modules.utils.trim(value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\tif(out.length > 0) {\n\t\t\t\tif(propertyType === 'p') {\n\t\t\t\t\treturn modules.text.parseText( this.document, out.join(''), this.options.textFormat);\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'u') {\n\t\t\t\t\treturn out.join('');\n\t\t\t\t}\n\t\t\t\tif(propertyType === 'dt') {\n\t\t\t\t\tvar format = 'microformat2';\n\t\t\t\t\treturn modules.dates.concatFragments(out,format).toString(format);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * returns a single string of the 'title' attr from all\n\t\t * the child nodes with the class 'value-title'\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetValueTitle: function(node) {\n\t\t\tvar out = [],\n\t\t\t\titems,\n\t\t\t\ti,\n\t\t\t\tx;\n\n\t\t\titems = modules.domUtils.getNodesByAttributeValue(node, 'class', 'value-title');\n\t\t\tx = 0;\n\t\t\ti = items.length;\n\t\t\twhile(x < i) {\n\t\t\t\tif(modules.domUtils.hasAttribute(items[x], 'title')) {\n\t\t\t\t\tout.push(modules.domUtils.getAttribute(items[x], 'title'));\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t},\n\n\n\t   /**\n\t\t * finds out whether a node has h-* class v1 and v2\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasHClass: function(node){\n\t\t\tvar classes = this.getUfClassNames(node);\n\t\t\tif(classes.root && classes.root.length > 0){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get both the root and property class names from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} ufNameArr\n\t\t * @return {Object}\n\t\t */\n\t\tgetUfClassNames: function(node, ufNameArr) {\n\t\t\tvar context = this,\n\t\t\t\tout = {\n\t\t\t\t\t'root': [],\n\t\t\t\t\t'properties': []\n\t\t\t\t},\n\t\t\t\tclassNames,\n\t\t\t\tkey,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty,\n\t\t\t\tmap,\n\t\t\t\tprop,\n\t\t\t\tpropName,\n\t\t\t\tv2Name,\n\t\t\t\timpiedRel,\n\t\t\t\tufName;\n\n\t\t\t// don't get classes from excluded list of tags\n\t\t\tif(modules.domUtils.hasTagName(node, this.excludeTags) === false){\n\n\t\t\t\t// find classes for node\n\t\t\t\tclassNames = modules.domUtils.getAttribute(node, 'class');\n\t\t\t\tif(classNames) {\n\t\t\t\t\titems = classNames.split(' ');\n\t\t\t\t\tx = 0;\n\t\t\t\t\ti = items.length;\n\t\t\t\t\twhile(x < i) {\n\n\t\t\t\t\t\titem = modules.utils.trim(items[x]);\n\n\t\t\t\t\t\t// test for root prefix - v2\n\t\t\t\t\t\tif(modules.utils.startWith(item, context.rootPrefix) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\tif(out.root.indexOf(item) === -1){\n\t\t\t\t\t\t\t\tout.root.push(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tout.typeVersion = 'v2';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for property prefix - v2\n\t\t\t\t\t\tz = context.propertyPrefixes.length;\n\t\t\t\t\t\twhile(z--) {\n\t\t\t\t\t\t\tif(modules.utils.startWith(item, context.propertyPrefixes[z]) && modules.utils.isLowerCase(item)) {\n\t\t\t\t\t\t\t\tout.properties.push([item,'v2']);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// test for mapped root classnames v1\n\t\t\t\t\t\tfor(key in modules.maps) {\n\t\t\t\t\t\t\tif(modules.maps.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t// only add a root once\n\t\t\t\t\t\t\t\tif(modules.maps[key].root === item && out.root.indexOf(key) === -1) {\n\t\t\t\t\t\t\t\t\t// if root map has subTree set to true\n\t\t\t\t\t\t\t\t\t// test to see if we should create a property or root\n\t\t\t\t\t\t\t\t\tif(modules.maps[key].subTree) {\n\t\t\t\t\t\t\t\t\t\tout.properties.push(['p-' + modules.maps[key].root, 'v1']);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tout.root.push(key);\n\t\t\t\t\t\t\t\t\t\tif(!out.typeVersion){\n\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// test for mapped property classnames v1\n\t\t\t\t\t\tif(ufNameArr){\n\t\t\t\t\t\t\tfor (var a = 0; a < ufNameArr.length; a++) {\n\t\t\t\t\t\t\t\tufName = ufNameArr[a];\n\t\t\t\t\t\t\t\t// get mapped property v1 microformat\n\t\t\t\t\t\t\t\tmap = context.getMapping(ufName);\n\t\t\t\t\t\t\t\tif(map) {\n\t\t\t\t\t\t\t\t\tfor(key in map.properties) {\n\t\t\t\t\t\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\n\t\t\t\t\t\t\t\t\t\t\tprop = map.properties[key];\n\t\t\t\t\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key;\n\n\t\t\t\t\t\t\t\t\t\t\tif(key === item) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// loop all the classList make sure\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   1. this property is a root\n\t\t\t\t\t\t\t\t\t\t\t\t\t//   2. that there is not already an equivalent v2 property i.e. url and u-url on the same element\n\t\t\t\t\t\t\t\t\t\t\t\t\ty = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(y < i) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2Name = context.getV2RootName(items[y]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// add new root\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(prop.uf.indexOf(v2Name) > -1 && out.root.indexOf(v2Name) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.root.push(v2Name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.typeVersion = 'v1';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ty++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t//only add property once\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(out.properties.indexOf(propName) === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tout.properties.push([propName,'v1']);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx++;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// finds any alt rel=* mappings for a given node/microformat\n\t\t\tif(ufNameArr && this.findRelImpied){\n\t\t\t\tfor (var b = 0; b < ufNameArr.length; b++) {\n\t\t\t\t\tufName = ufNameArr[b];\n\t\t\t\t\timpiedRel = this.findRelImpied(node, ufName);\n\t\t\t\t\tif(impiedRel && out.properties.indexOf(impiedRel) === -1) {\n\t\t\t\t\t\tout.properties.push([impiedRel, 'v1']);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t//if(out.root.length === 1 && out.properties.length === 1) {\n\t\t\t//\tif(out.root[0].replace('h-','') === this.removePropPrefix(out.properties[0][0])) {\n\t\t\t//\t\tout.typeVersion = 'v2';\n\t\t\t//\t}\n\t\t\t//}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 or v2 root name, return mapping object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {Object || null}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name || key === name) {\n\t\t\t\t\treturn modules.maps[key];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * given a v1 root name returns a v2 root name i.e. vcard >>> h-card\n\t\t *\n\t\t * @param  {String} name\n\t\t * @return {String || null}\n\t\t */\n\t\tgetV2RootName: function(name) {\n\t\t\tvar key;\n\t\t\tfor(key in modules.maps) {\n\t\t\t\tif(modules.maps[key].root === name) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t\t/**\n\t\t * whether a property is the right microformats version for its root type\n\t\t *\n\t\t * @param  {String} typeVersion\n\t\t * @param  {String} propertyVersion\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedPropertyVersion: function(typeVersion, propertyVersion){\n\t\t\tif(this.options.overlappingVersions === true){\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\treturn (typeVersion === propertyVersion);\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * creates a blank microformats object\n\t\t *\n\t\t * @param  {String} name\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tcreateUfObject: function(names, typeVersion, value) {\n\t\t\tvar out = {};\n\n\t\t\t// is more than just whitespace\n\t\t\tif(value && modules.utils.isOnlyWhiteSpace(value) === false) {\n\t\t\t\tout.value = value;\n\t\t\t}\n\t\t\t// add type i.e. [\"h-card\", \"h-org\"]\n\t\t\tif(modules.utils.isArray(names)) {\n\t\t\t\tout.type = names;\n\t\t\t} else {\n\t\t\t\tout.type = [names];\n\t\t\t}\n\t\t\tout.properties = {};\n\t\t\t// metadata properties for parsing\n\t\t\tout.typeVersion = typeVersion;\n\t\t\tout.times = [];\n\t\t\tout.dates = [];\n\t\t\tout.altValue = null;\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * removes unwanted microformats property before output\n\t\t *\n\t\t * @param  {Object} microformat\n\t\t */\n\t\tcleanUfObject: function( microformat ) {\n\t\t\tdelete microformat.times;\n\t\t\tdelete microformat.dates;\n\t\t\tdelete microformat.typeVersion;\n\t\t\tdelete microformat.altValue;\n\t\t\treturn microformat;\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes microformat property prefixes from text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremovePropPrefix: function(text) {\n\t\t\tvar i;\n\n\t\t\ti = this.propertyPrefixes.length;\n\t\t\twhile(i--) {\n\t\t\t\tvar prefix = this.propertyPrefixes[i];\n\t\t\t\tif(modules.utils.startWith(text, prefix) && modules.utils.isLowerCase(text)) {\n\t\t\t\t\ttext = text.substr(prefix.length);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn text;\n\t\t},\n\n\n\t\t/**\n\t\t * expands all relative URLs to absolute ones where it can\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attrName\n\t\t * @param  {String} baseUrl\n\t\t */\n\t\texpandURLs: function(node, attrName, baseUrl){\n\t\t\tvar i,\n\t\t\t\tnodes,\n\t\t\t\tattr;\n\n\t\t\tnodes = modules.domUtils.getNodesByAttribute(node, attrName);\n\t\t\ti = nodes.length;\n\t\t\twhile (i--) {\n\t\t\t\ttry{\n\t\t\t\t\t// the url parser can blow up if the format is not right\n\t\t\t\t\tattr = modules.domUtils.getAttribute(nodes[i], attrName);\n\t\t\t\t\tif(attr && attr !== '' && baseUrl !== '' && attr.indexOf('://') === -1) {\n\t\t\t\t\t\t//attr = urlParser.resolve(baseUrl, attr);\n\t\t\t\t\t\tattr = modules.url.resolve(attr, baseUrl);\n\t\t\t\t\t\tmodules.domUtils.setAttribute(nodes[i], attrName, attr);\n\t\t\t\t\t}\n\t\t\t\t}catch(err){\n\t\t\t\t\t// do nothing - convert only the urls we can, leave the rest as they are\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\n\t\t/**\n\t\t * merges passed and default options -single level clone of properties\n\t\t *\n\t\t * @param  {Object} options\n\t\t */\n\t\tmergeOptions: function(options) {\n\t\t\tvar key;\n\t\t\tfor(key in options) {\n\t\t\t\tif(options.hasOwnProperty(key)) {\n\t\t\t\t\tthis.options[key] = options[key];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all rootid attributes\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tremoveRootIds: function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rootids');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeAttribute(arr[i],'rootids');\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes all changes made to the DOM\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t */\n\t\tclearUpDom: function(rootNode){\n\t\t\tif(this.removeIncludes){\n\t\t\t\tthis.removeIncludes(rootNode);\n\t\t\t}\n\t\t\tthis.removeRootIds(rootNode);\n\t\t}\n\n\n\t};\n\n\n\tmodules.Parser.prototype.constructor = modules.Parser;\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\t\t/**\n\t\t * applies \"implied rules\" microformat output structure i.e. feed-title, name, photo, url and date\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf (microformat output structure)\n\t\t * @param  {Object} parentClasses (classes structure)\n\t\t * @param  {Boolean} impliedPropertiesByVersion\n\t\t * @return {Object}\n\t\t */\n\t\t modules.Parser.prototype.impliedRules = function(node, uf, parentClasses) {\n\t\t\tvar typeVersion = (uf.typeVersion)? uf.typeVersion: 'v2';\n\n\t\t\t// TEMP: override to allow v1 implied properties while spec changes\n\t\t\tif(this.options.impliedPropertiesByVersion === false){\n\t\t\t\ttypeVersion = 'v2';\n\t\t\t}\n\n\t\t\tif(node && uf && uf.properties) {\n\t\t\t\tuf = this.impliedBackwardComp( node, uf, parentClasses );\n\t\t\t\tif(typeVersion === 'v2'){\n\t\t\t\t\tuf = this.impliedhFeedTitle( uf );\n\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\tuf = this.impliedPhoto( node, uf );\n\t\t\t\t\tuf = this.impliedUrl( node, uf );\n\t\t\t\t}\n\t\t\t\tuf = this.impliedValue( node, uf, parentClasses );\n\t\t\t\tuf = this.impliedDate( uf );\n\n\t\t\t\t// TEMP: flagged while spec changes are put forward\n\t\t\t\tif(this.options.parseLatLonGeo === true){\n\t\t\t\t\tuf = this.impliedGeo( uf );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied name rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedName = function(node, uf) {\n\t\t\t// implied name rule\n\t\t\t/*\n\t\t\t\timg.h-x[alt]\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" src=\"glenn.htm\" alt=\"Glenn Jones\"></a>\n\t\t\t\tarea.h-x[alt] \t\t\t\t\t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.htm\" alt=\"Glenn Jones\"></area>\n\t\t\t\tabbr.h-x[title]\t\t\t\t\t\t\t\t\t\t<abbr class=\"h-card\" title=\"Glenn Jones\"GJ</abbr>\n\n\t\t\t\t.h-x>img:only-child[alt]:not[.h-*]\t\t\t\t\t<div class=\"h-card\"><a src=\"glenn.htm\" alt=\"Glenn Jones\"></a></div>\n\t\t\t\t.h-x>area:only-child[alt]:not[.h-*] \t\t\t\t<div class=\"h-card\"><area href=\"glenn.htm\" alt=\"Glenn Jones\"></area></div>\n\t\t\t\t.h-x>abbr:only-child[title] \t\t\t\t\t\t<div class=\"h-card\"><abbr title=\"Glenn Jones\">GJ</abbr></div>\n\n\t\t\t\t.h-x>:only-child>img:only-child[alt]:not[.h-*] \t\t<div class=\"h-card\"><span><img src=\"jane.html\" alt=\"Jane Doe\"/></span></div>\n\t\t\t\t.h-x>:only-child>area:only-child[alt]:not[.h-*] \t<div class=\"h-card\"><span><area href=\"jane.html\" alt=\"Jane Doe\"></area></span></div>\n\t\t\t\t.h-x>:only-child>abbr:only-child[title]\t\t\t\t<div class=\"h-card\"><span><abbr title=\"Jane Doe\">JD</abbr></span></div>\n\t\t\t*/\n\t\t\tvar name,\n\t\t\t\tvalue;\n\n\t\t\tif(!uf.properties.name) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'area', 'abbr'], this.getNameAttr);\n\t\t\t\tvar textFormat = this.options.textFormat;\n\t\t\t\t// if no value for tags/properties use text\n\t\t\t\tif(!value) {\n\t\t\t\t\tname = [modules.text.parse(this.document, node, textFormat)];\n\t\t\t\t}else{\n\t\t\t\t\tname = [modules.text.parseText(this.document, value, textFormat)];\n\t\t\t\t}\n\t\t\t\tif(name && name[0] !== ''){\n\t\t\t\t\tuf.properties.name = name;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied photo rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedPhoto = function(node, uf) {\n\t\t\t// implied photo rule\n\t\t\t/*\n\t\t\t\timg.h-x[src] \t\t\t\t\t\t\t\t\t\t\t\t<img class=\"h-card\" alt=\"Jane Doe\" src=\"jane.jpeg\"/>\n\t\t\t\tobject.h-x[data] \t\t\t\t\t\t\t\t\t\t\t<object class=\"h-card\" data=\"jane.jpeg\"/>Jane Doe</object>\n\t\t\t\t.h-x>img[src]:only-of-type:not[.h-*]\t\t\t\t\t\t<div class=\"h-card\"><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></div>\n\t\t\t\t.h-x>object[data]:only-of-type:not[.h-*] \t\t\t\t\t<div class=\"h-card\"><object data=\"jane.jpeg\"/>Jane Doe</object></div>\n\t\t\t\t.h-x>:only-child>img[src]:only-of-type:not[.h-*] \t\t\t<div class=\"h-card\"><span><img alt=\"Jane Doe\" src=\"jane.jpeg\"/></span></div>\n\t\t\t\t.h-x>:only-child>object[data]:only-of-type:not[.h-*] \t\t<div class=\"h-card\"><span><object data=\"jane.jpeg\"/>Jane Doe</object></span></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.photo) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['img', 'object'], this.getPhotoAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.photo = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied URL rule\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedUrl = function(node, uf) {\n\t\t\t// implied URL rule\n\t\t\t/*\n\t\t\t\ta.h-x[href]  \t\t\t\t\t\t\t<a class=\"h-card\" href=\"glenn.html\">Glenn</a>\n\t\t\t\tarea.h-x[href]  \t\t\t\t\t\t<area class=\"h-card\" href=\"glenn.html\">Glenn</area>\n\t\t\t\t.h-x>a[href]:only-of-type:not[.h-*]  \t<div class=\"h-card\" ><a href=\"glenn.html\">Glenn</a><p>...</p></div>\n\t\t\t\t.h-x>area[href]:only-of-type:not[.h-*]  <div class=\"h-card\" ><area href=\"glenn.html\">Glenn</area><p>...</p></div>\n\t\t\t*/\n\t\t\tvar value;\n\t\t\tif(!uf.properties.url) {\n\t\t\t\tvalue = this.getImpliedProperty(node, ['a', 'area'], this.getURLAttr);\n\t\t\t\tif(value) {\n\t\t\t\t\t// relative to absolute URL\n\t\t\t\t\tif(value && value !== '' && this.options.baseUrl !== '' && value.indexOf('://') === -1) {\n\t\t\t\t\t\tvalue = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t}\n\t\t\t\t\tuf.properties.url = [modules.utils.trim(value)];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * apply implied date rule - if there is a time only property try to concat it with any date property\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedDate = function(uf) {\n\t\t\t// implied date rule\n\t\t\t// http://microformats.org/wiki/value-class-pattern#microformats2_parsers\n\t\t\t// http://microformats.org/wiki/microformats2-parsing-issues#implied_date_for_dt_properties_both_mf2_and_backcompat\n\t\t\tvar newDate;\n\t\t\tif(uf.times.length > 0 && uf.dates.length > 0) {\n\t\t\t\tnewDate = modules.dates.dateTimeUnion(uf.dates[0][1], uf.times[0][1], 'microformat2');\n\t\t\t\t//uf.properties[this.removePropPrefix(uf.times[0][0])][0] = newDate.toString('microformat2');\n\t\t\t\tvar key = this.removePropPrefix(uf.times[0][0]);\n \t\t\t\tif (!!(key.length) && Array.isArray(uf.properties[key])) {\n \t\t\t\t\tuf.properties[key][0] = newDate.toString('microformat2');\n \t\t\t\t}\n\t\t\t}\n\t\t\t// clean-up object\n\t\t\tdelete uf.times;\n\t\t\tdelete uf.dates;\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied property value from pre-defined tag/attriubte combinations\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} tagList (Array of tags from which an implied value can be pulled)\n\t\t * @param  {String} getAttrFunction (Function which can extract implied value)\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getImpliedProperty = function(node, tagList, getAttrFunction) {\n\t\t\t// i.e. img.h-card\n\t\t\tvar value = getAttrFunction(node),\n\t\t\t\tdescendant,\n\t\t\t\tchild;\n\n\t\t\tif(!value) {\n\t\t\t\t// i.e. .h-card>img:only-of-type:not(.h-card)\n\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType( node, tagList);\n\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t}\n\t\t\t\tif(node.children.length > 0 ){\n\t\t\t\t\t// i.e.  .h-card>:only-child>img:only-of-type:not(.h-card)\n\t\t\t\t\tchild = modules.domUtils.getSingleDescendant(node);\n\t\t\t\t\tif(child && this.hasHClass(child) === false){\n\t\t\t\t\t\tdescendant = modules.domUtils.getSingleDescendantOfType(child, tagList);\n\t\t\t\t\t\tif(descendant && this.hasHClass(descendant) === false){\n\t\t\t\t\t\t\tvalue = getAttrFunction(descendant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied name value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getNameAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img','area'], 'alt');\n\t\t\tif(!value) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['abbr'], 'title');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getPhotoAttr = function(node) {\n\t\t\tvar value = modules.domUtils.getAttrValFromTagList(node, ['img'], 'src');\n\t\t\tif(!value && modules.domUtils.hasAttributeValue(node, 'class', 'include') === false) {\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['object'], 'data');\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t * get an implied photo value from a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String || null}\n\t\t */\n\t\tmodules.Parser.prototype.getURLAttr = function(node) {\n\t\t\tvar value = null;\n\t\t\tif(modules.domUtils.hasAttributeValue(node, 'class', 'include') === false){\n\n\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['a'], 'href');\n\t\t\t\tif(!value) {\n\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(node, ['area'], 'href');\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\n\t\t/**\n\t\t *\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedValue = function(node, uf, parentClasses){\n\n\t\t\t// intersection of implied name and implied value rules\n\t\t\tif(uf.properties.name) {\n\t\t\t\tif(uf.value && parentClasses.root.length > 0 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'p-name', uf.properties.name[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// intersection of implied URL and implied value rules\n\t\t\tif(uf.properties.url) {\n\t\t\t\tif(parentClasses && parentClasses.root.length === 1 && parentClasses.properties.length === 1){\n\t\t\t\t\tuf = this.getAltValue(uf, parentClasses.properties[0][0], 'u-url', uf.properties.url[0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// apply alt value\n\t\t\tif(uf.altValue !== null){\n\t\t\t\tuf.value = uf.altValue.value;\n\t\t\t}\n\t\t\tdelete uf.altValue;\n\n\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * get alt value based on rules about parent property prefix\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @param  {String} parentPropertyName\n\t\t * @param  {String} propertyName\n\t\t * @param  {String} value\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getAltValue = function(uf, parentPropertyName, propertyName, value){\n\t\t\tif(uf.value && !uf.altValue){\n\t\t\t\t// first p-name of the h-* child\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'p-') && propertyName === 'p-name'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an e-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'e-') && modules.utils.startWith(propertyName,'e-')){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t\t// if it's an u-* property element\n\t\t\t\tif(modules.utils.startWith(parentPropertyName,'u-') && propertyName === 'u-url'){\n\t\t\t\t\tuf.altValue = {name: propertyName, value: value};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a h-feed does not have a title use the title tag of a page\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedhFeedTitle = function( uf ){\n\t\t\tif(uf.type && uf.type.indexOf('h-feed') > -1){\n\t\t\t\t// has no name property\n\t\t\t\tif(uf.properties.name === undefined || uf.properties.name[0] === '' ){\n\t\t\t\t\t// use the text from the title tag\n\t\t\t\t\tvar title = modules.domUtils.querySelector(this.document, 'title');\n\t\t\t\t\tif(title){\n\t\t\t\t\t\tuf.properties.name = [modules.domUtils.textContent(title)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t    /**\n\t\t * implied Geo from pattern <abbr class=\"p-geo\" title=\"37.386013;-122.082932\">\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedGeo = function( uf ){\n\t\t\tvar geoPair,\n\t\t\t\tparts,\n\t\t\t\tlongitude,\n\t\t\t\tlatitude,\n\t\t\t\tvalid = true;\n\n\t\t\tif(uf.type && uf.type.indexOf('h-geo') > -1){\n\n\t\t\t\t// has no latitude or longitude property\n\t\t\t\tif(uf.properties.latitude === undefined || uf.properties.longitude === undefined ){\n\n\t\t\t\t\tgeoPair = (uf.properties.name)? uf.properties.name[0] : null;\n\t\t\t\t\tgeoPair = (!geoPair && uf.properties.value)? uf.properties.value : geoPair;\n\n\t\t\t\t\tif(geoPair){\n\t\t\t\t\t\t// allow for the use of a ';' as in microformats and also ',' as in Geo URL\n\t\t\t\t\t\tgeoPair = geoPair.replace(';',',');\n\n\t\t\t\t\t\t// has sep char\n\t\t\t\t\t\tif(geoPair.indexOf(',') > -1 ){\n\t\t\t\t\t\t\tparts = geoPair.split(',');\n\n\t\t\t\t\t\t\t// only correct if we have two or more parts\n\t\t\t\t\t\t\tif(parts.length > 1){\n\n\t\t\t\t\t\t\t\t// latitude no value outside the range -90 or 90\n\t\t\t\t\t\t\t\tlatitude = parseFloat( parts[0] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(latitude) && latitude > 90 || latitude < -90){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// longitude no value outside the range -180 to 180\n\t\t\t\t\t\t\t\tlongitude = parseFloat( parts[1] );\n\t\t\t\t\t\t\t\tif(modules.utils.isNumber(longitude) && longitude > 180 || longitude < -180){\n\t\t\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif(valid){\n\t\t\t\t\t\t\t\t\tuf.properties.latitude = [latitude];\n\t\t\t\t\t\t\t\t\tuf.properties.longitude  = [longitude];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn uf;\n\t\t};\n\n\n\t\t/**\n\t\t * if a backwards compat built structure has no properties add name through this.impliedName\n\t\t *\n\t\t * @param  {Object} uf\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.impliedBackwardComp = function(node, uf, parentClasses){\n\n\t\t\t// look for pattern in parent classes like \"p-geo h-geo\"\n\t\t\t// these are structures built from backwards compat parsing of geo\n\t\t\tif(parentClasses.root.length === 1 && parentClasses.properties.length === 1) {\n\t\t\t\tif(parentClasses.root[0].replace('h-','') === this.removePropPrefix(parentClasses.properties[0][0])) {\n\n\t\t\t\t\t// if microformat has no properties apply the impliedName rule to get value from containing node\n\t\t\t\t\t// this will get value from html such as <abbr class=\"geo\" title=\"30.267991;-97.739568\">Brighton</abbr>\n\t\t\t\t\tif( modules.utils.hasProperties(uf.properties) === false ){\n\t\t\t\t\t\tuf = this.impliedName( node, uf );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn uf;\n\t\t};\n\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addIncludes = function(rootNode) {\n\t\t\tthis.addAttributeIncludes(rootNode, 'itemref');\n\t\t\tthis.addAttributeIncludes(rootNode, 'headers');\n\t\t\tthis.addClassIncludes(rootNode);\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for attribute based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tmodules.Parser.prototype.addAttributeIncludes = function(rootNode, attributeName) {\n\t\t\tvar arr,\n\t\t\t\tidList,\n\t\t\t\ti,\n\t\t\t\tx,\n\t\t\t\tz,\n\t\t\t\ty;\n\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, attributeName);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tidList = modules.domUtils.getAttributeList(arr[x], attributeName);\n\t\t\t\tif(idList) {\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = idList.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\tthis.apppendInclude(arr[x], idList[z]);\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends clones of include Nodes into the DOM structure for class based includes\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.addClassIncludes = function(rootNode) {\n\t\t\tvar id,\n\t\t\t\tarr,\n\t\t\t\tx = 0,\n\t\t\t\ti;\n\n\t\t\tarr = modules.domUtils.getNodesByAttributeValue(rootNode, 'class', 'include');\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['a'], 'href');\n\t\t\t\tif(!id) {\n\t\t\t\t\tid = modules.domUtils.getAttrValFromTagList(arr[x], ['object'], 'data');\n\t\t\t\t}\n\t\t\t\tthis.apppendInclude(arr[x], id);\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * appends a clone of an include into another Node using Id\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @param  {Stringe} id\n\t\t */\n\t\tmodules.Parser.prototype.apppendInclude = function(node, id){\n\t\t\tvar include,\n\t\t\t\tclone;\n\n\t\t\tif(id){\n\t\t\t\tid = modules.utils.trim(id.replace('#', ''));\n\t\t\t\tinclude = modules.domUtils.getElementById(this.document, id);\n\t\t\t\tif(include) {\n\t\t\t\t\tclone = modules.domUtils.clone(include);\n\t\t\t\t\tthis.markIncludeChildren(clone);\n\t\t\t\t\tmodules.domUtils.appendChild(node, clone);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * adds an attribute marker to all the child microformat roots\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.markIncludeChildren = function(rootNode) {\n\t\t\tvar arr,\n\t\t\t\tx,\n\t\t\t\ti;\n\n\t\t\t// loop the array and add the attribute\n\t\t\tarr = this.findRootNodes(rootNode);\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'data-include', 'true');\n\t\t\tmodules.domUtils.setAttribute(rootNode, 'style', 'display:none');\n\t\t\twhile(x < i) {\n\t\t\t\tmodules.domUtils.setAttribute(arr[x], 'data-include', 'true');\n\t\t\t\tx++;\n\t\t\t}\n\t\t};\n\n\n\t\t/**\n\t\t * removes all appended include clones from DOM\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t */\n\t\tmodules.Parser.prototype.removeIncludes = function(rootNode){\n\t\t\tvar arr,\n\t\t\t\ti;\n\n\t\t\t// remove all the items that were added as includes\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'data-include');\n\t\t\ti = arr.length;\n\t\t\twhile(i--) {\n\t\t\t\tmodules.domUtils.removeChild(rootNode,arr[i]);\n\t\t\t}\n\t\t};\n\n\n\t}\n\n\n\t// check parser module is loaded\n\tif(modules.Parser){\n\t\n\t\t/**\n\t\t * finds rel=* structures\n\t\t *\n\t\t * @param  {DOM node} rootNode\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.findRels = function(rootNode) {\n\t\t\tvar out = {\n\t\t\t\t\t'items': [],\n\t\t\t\t\t'rels': {},\n\t\t\t\t\t'rel-urls': {}\n\t\t\t\t},\n\t\t\t\tx,\n\t\t\t\ti,\n\t\t\t\ty,\n\t\t\t\tz,\n\t\t\t\trelList,\n\t\t\t\titems,\n\t\t\t\titem,\n\t\t\t\tvalue,\n\t\t\t\tarr;\n\t\n\t\t\tarr = modules.domUtils.getNodesByAttribute(rootNode, 'rel');\n\t\t\tx = 0;\n\t\t\ti = arr.length;\n\t\t\twhile(x < i) {\n\t\t\t\trelList = modules.domUtils.getAttribute(arr[x], 'rel');\n\t\n\t\t\t\tif(relList) {\n\t\t\t\t\titems = relList.split(' ');\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// add rels\n\t\t\t\t\tz = 0;\n\t\t\t\t\ty = items.length;\n\t\t\t\t\twhile(z < y) {\n\t\t\t\t\t\titem = modules.utils.trim(items[z]);\n\t\n\t\t\t\t\t\t// get rel value\n\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['a', 'area'], 'href');\n\t\t\t\t\t\tif(!value) {\n\t\t\t\t\t\t\tvalue = modules.domUtils.getAttrValFromTagList(arr[x], ['link'], 'href');\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// create the key\n\t\t\t\t\t\tif(!out.rels[item]) {\n\t\t\t\t\t\t\tout.rels[item] = [];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif(typeof this.options.baseUrl === 'string' && typeof value === 'string') {\n\t\t\t\t\t\n\t\t\t\t\t\t\tvar resolved = modules.url.resolve(value, this.options.baseUrl);\n\t\t\t\t\t\t\t// do not add duplicate rels - based on resolved URLs\n\t\t\t\t\t\t\tif(out.rels[item].indexOf(resolved) === -1){\n\t\t\t\t\t\t\t\tout.rels[item].push( resolved );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar url = null;\n\t\t\t\t\tif(modules.domUtils.hasAttribute(arr[x], 'href')){\n\t\t\t\t\t\turl = modules.domUtils.getAttribute(arr[x], 'href');\n\t\t\t\t\t\tif(url){\n\t\t\t\t\t\t\turl = modules.url.resolve(url, this.options.baseUrl );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t\n\t\t\t\t\t// add to rel-urls\n\t\t\t\t\tvar relUrl = this.getRelProperties(arr[x]);\n\t\t\t\t\trelUrl.rels = items;\n\t\t\t\t\t// // do not add duplicate rel-urls - based on resolved URLs\n\t\t\t\t\tif(url && out['rel-urls'][url] === undefined){\n\t\t\t\t\t\tout['rel-urls'][url] = relUrl;\n\t\t\t\t\t}\n\t\n\t\t\t\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * gets the properties of a rel=*\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Object}\n\t\t */\n\t\tmodules.Parser.prototype.getRelProperties = function(node){\n\t\t\tvar obj = {};\n\t\t\t\n\t\t\tif(modules.domUtils.hasAttribute(node, 'media')){\n\t\t\t\tobj.media = modules.domUtils.getAttribute(node, 'media');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'type')){\n\t\t\t\tobj.type = modules.domUtils.getAttribute(node, 'type');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'hreflang')){\n\t\t\t\tobj.hreflang = modules.domUtils.getAttribute(node, 'hreflang');\n\t\t\t}\n\t\t\tif(modules.domUtils.hasAttribute(node, 'title')){\n\t\t\t\tobj.title = modules.domUtils.getAttribute(node, 'title');\n\t\t\t}\n\t\t\tif(modules.utils.trim(this.getPValue(node, false)) !== ''){\n\t\t\t\tobj.text = this.getPValue(node, false);\n\t\t\t}\t\n\t\t\t\n\t\t\treturn obj;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * finds any alt rel=* mappings for a given node/microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @param  {String} ufName\n\t\t * @return {String || undefined}\n\t\t */\n\t\tmodules.Parser.prototype.findRelImpied = function(node, ufName) {\n\t\t\tvar out,\n\t\t\t\tmap,\n\t\t\t\ti;\n\t\n\t\t\tmap = this.getMapping(ufName);\n\t\t\tif(map) {\n\t\t\t\tfor(var key in map.properties) {\n\t\t\t\t\tif (map.properties.hasOwnProperty(key)) {\n\t\t\t\t\t\tvar prop = map.properties[key],\n\t\t\t\t\t\t\tpropName = (prop.map) ? prop.map : 'p-' + key,\n\t\t\t\t\t\t\trelCount = 0;\n\t\t\n\t\t\t\t\t\t// is property an alt rel=* mapping \n\t\t\t\t\t\tif(prop.relAlt && modules.domUtils.hasAttribute(node, 'rel')) {\n\t\t\t\t\t\t\ti = prop.relAlt.length;\n\t\t\t\t\t\t\twhile(i--) {\n\t\t\t\t\t\t\t\tif(modules.domUtils.hasAttributeValue(node, 'rel', prop.relAlt[i])) {\n\t\t\t\t\t\t\t\t\trelCount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(relCount === prop.relAlt.length) {\n\t\t\t\t\t\t\t\tout = propName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns whether a node or its children has rel=* microformat\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tmodules.Parser.prototype.hasRel = function(node) {\n\t\t\treturn (this.countRels(node) > 0);\n\t\t};\n\t\t\n\t\t\n\t\t/**\n\t\t * returns the number of rel=* microformats\n\t\t *\n\t\t * @param  {DOM node} node\n\t\t * @return {Int}\n\t\t */\n\t\tmodules.Parser.prototype.countRels = function(node) {\n\t\t\tif(node){\n\t\t\t\treturn modules.domUtils.getNodesByAttribute(node, 'rel').length;\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\n\t\n\t\t\n\t}\n\n\n\tmodules.utils = {\n\n\t\t/**\n\t\t * is the object a string\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisString: function( obj ) {\n\t\t\treturn typeof( obj ) === 'string';\n\t\t},\n\n\t\t/**\n\t\t * is the object a number\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisNumber: function( obj ) {\n\t\t\treturn !isNaN(parseFloat( obj )) && isFinite( obj );\n\t\t},\n\n\n\t\t/**\n\t\t * is the object an array\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisArray: function( obj ) {\n\t\t\treturn obj && !( obj.propertyIsEnumerable( 'length' ) ) && typeof obj === 'object' && typeof obj.length === 'number';\n\t\t},\n\n\n\t\t/**\n\t\t * is the object a function\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\tisFunction: function(obj) {\n\t\t\treturn !!(obj && obj.constructor && obj.call && obj.apply);\n\t\t},\n\n\n\t\t/**\n\t\t * does the text start with a test string\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} test\n\t\t * @return {Boolean}\n\t\t */\n\t\tstartWith: function( text, test ) {\n\t\t\treturn(text.indexOf(test) === 0);\n\t\t},\n\n\n\t\t/**\n\t\t * is string all lowerCase - just checks letters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisLowerCase: function( text ) {\n\t\t\treturn text === text.toLowerCase();\n\t\t},\n\n\n\n\t\t/**\n\t\t * removes spaces at front and back of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function( text ) {\n\t\t\tif(text && this.isString(text)){\n\t\t\t\treturn (text.trim())? text.trim() : text.replace(/^\\s+|\\s+$/g, '');\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * replaces a character in text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {Int} index\n\t\t * @param  {String} character\n\t\t * @return {String}\n\t\t */\n\t\treplaceCharAt: function( text, index, character ) {\n\t\t\tif(text && text.length > index){\n\t\t\t   return text.substr(0, index) + character + text.substr(index+character.length);\n\t\t\t}else{\n\t\t\t\treturn text;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace, tabs and returns from start and end of text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrimWhitespace: function( text ){\n\t\t\tif(text && text.length){\n\t\t\t\tvar i = text.length,\n\t\t\t\t\tx = 0;\n\n\t\t\t\t// turn all whitespace chars at end into spaces\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[i])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// turn all whitespace chars at start into spaces\n\t\t\t\ti = text.length;\n\t\t\t\twhile (x < i) {\n\t\t\t\t\tif(this.isOnlyWhiteSpace(text[x])){\n\t\t\t\t\t\ttext = this.replaceCharAt( text, i, ' ' );\n\t\t\t\t\t}else{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.trim(text);\n\t\t},\n\n\n\t\t/**\n\t\t * does text only contain whitespace characters\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisOnlyWhiteSpace: function( text ){\n\t\t\treturn !(/[^\\t\\n\\r ]/.test( text ));\n\t\t},\n\n\n\t\t/**\n\t\t * removes whitespace from text (leaves a single space)\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Sring}\n\t\t */\n\t\tcollapseWhiteSpace: function( text ){\n\t\t\treturn text.replace(/[\\t\\n\\r ]+/g, ' ');\n\t\t},\n\n\n\t\t/**\n\t\t * does an object have any of its own properties\n\t\t *\n\t\t * @param  {Object} obj\n\t\t * @return {Boolean}\n\t\t */\n\t\thasProperties: function( obj ) {\n\t\t\tvar key;\n\t\t\tfor(key in obj) {\n\t\t\t\tif( obj.hasOwnProperty( key ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * a sort function - to sort objects in an array by a given property\n\t\t *\n\t\t * @param  {String} property\n\t\t * @param  {Boolean} reverse\n\t\t * @return {Int}\n\t\t */\n\t\tsortObjects: function(property, reverse) {\n\t\t\treverse = (reverse) ? -1 : 1;\n\t\t\treturn function (a, b) {\n\t\t\t\ta = a[property];\n\t\t\t\tb = b[property];\n\t\t\t\tif (a < b) {\n\t\t\t\t\treturn reverse * -1;\n\t\t\t\t}\n\t\t\t\tif (a > b) {\n\t\t\t\t\treturn reverse * 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t};\n\t\t}\n\n\t};\n\n\n\tmodules.domUtils = {\n\n\t\t// blank objects for DOM\n\t\tdocument: null,\n\t\trootNode: null,\n\n\n\t     /**\n\t\t * gets DOMParser object\n\t\t *\n         * @return {Object || undefined}\n\t\t */\n        getDOMParser: function () {\n            if (typeof DOMParser === undefined) {\n                try {\n                    return Components.classes[\"@mozilla.org/xmlextras/domparser;1\"]\n                        .createInstance(Components.interfaces.nsIDOMParser);\n                } catch (e) {\n                    return;\n                }\n            } else {\n                return new DOMParser();\n            }\n        },\n\n\n\t     /**\n\t\t * configures what are the base DOM objects for parsing\n\t\t *\n\t\t * @param  {Object} options\n\t\t * @return {DOM Node} node\n\t\t */\n\t\tgetDOMContext: function( options ){\n\n\t\t\t// if a node is passed\n\t\t\tif(options.node){\n\t\t\t\tthis.rootNode = options.node;\n\t\t\t}\n\n\n\t\t\t// if a html string is passed\n\t\t\tif(options.html){\n\t\t\t\t//var domParser = new DOMParser();\n                var domParser = this.getDOMParser();\n       \t\t\tthis.rootNode = domParser.parseFromString( options.html, 'text/html' );\n\t\t\t}\n\n\n\t\t\t// find top level document from rootnode\n\t\t\tif(this.rootNode !== null){\n\t\t\t\tif(this.rootNode.nodeType === 9){\n\t\t\t\t\tthis.document = this.rootNode;\n\t\t\t\t\tthis.rootNode = modules.domUtils.querySelector(this.rootNode, 'html');\n\t\t\t\t}else{\n\t\t\t\t\t// if it's DOM node get parent DOM Document\n\t\t\t\t\tthis.document = modules.domUtils.ownerDocument(this.rootNode);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t// use global document object\n\t\t\tif(!this.rootNode && document){\n\t\t\t\tthis.rootNode = modules.domUtils.querySelector(document, 'html');\n\t\t\t\tthis.document = document;\n\t\t\t}\n\n\n\t\t\tif(this.rootNode && this.document){\n\t\t\t\treturn {document: this.document, rootNode: this.rootNode};\n\t\t\t}\n\n\t\t\treturn {document: null, rootNode: null};\n\t\t},\n\n\n\n\t\t/**\n\t\t* gets the first DOM node\n\t\t*\n\t\t* @param  {Dom Document}\n\t\t* @return {DOM Node} node\n\t\t*/\n\t\tgetTopMostNode: function( node ){\n\t\t\t//var doc = this.ownerDocument(node);\n\t\t\t//if(doc && doc.nodeType && doc.nodeType === 9 && doc.documentElement){\n\t\t\t//\treturn doc.documentElement;\n\t\t\t//}\n\t\t\treturn node;\n\t\t},\n\n\n\n\t\t /**\n\t\t * abstracts DOM ownerDocument\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Dom Document}\n\t\t */\n\t\townerDocument: function(node){\n\t\t\treturn node.ownerDocument;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM textContent\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\ttextContent: function(node){\n\t\t\tif(node.textContent){\n\t\t\t\treturn node.textContent;\n\t\t\t}else if(node.innerText){\n\t\t\t\treturn node.innerText;\n\t\t\t}\n\t\t\treturn '';\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM innerHTML\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tinnerHTML: function(node){\n\t\t\treturn node.innerHTML;\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM hasAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttribute: function(node, attributeName) {\n\t\t\tif(node.hasAttribute){\n\t\t\t\treturn node.hasAttribute(attributeName);\n\t\t\t}else{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does an attribute contain a value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} value\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAttributeValue: function(node, attributeName, value) {\n\t\t\treturn (this.getAttributeList(node, attributeName).indexOf(value) > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttribute: function(node, attributeName) {\n\t\t\treturn node.getAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM setAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @param  {String} attributeValue\n\t\t */\n\t\tsetAttribute: function(node, attributeName, attributeValue){\n\t\t\tnode.setAttribute(attributeName, attributeValue);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM removeAttribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t */\n\t\tremoveAttribute: function(node, attributeName) {\n\t\t\tnode.removeAttribute(attributeName);\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM getElementById\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} id\n\t\t * @return {DOM Node}\n\t\t */\n\t\tgetElementById: function(docNode, id) {\n\t\t\treturn docNode.querySelector( '#' + id );\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM querySelector\n\t\t *\n\t\t * @param  {DOM Node || DOM Document} node\n\t\t * @param  {String} selector\n\t\t * @return {DOM Node}\n\t\t */\n\t\tquerySelector: function(docNode, selector) {\n\t\t\treturn docNode.querySelector( selector );\n\t\t},\n\n\n\t\t/**\n\t\t * get value of a Node attribute as an array\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {Array}\n\t\t */\n\t\tgetAttributeList: function(node, attributeName) {\n\t\t\tvar out = [],\n\t\t\t\tattList;\n\n\t\t\tattList = node.getAttribute(attributeName);\n\t\t\tif(attList && attList !== '') {\n\t\t\t\tif(attList.indexOf(' ') > -1) {\n\t\t\t\t\tout = attList.split(' ');\n\t\t\t\t} else {\n\t\t\t\t\tout.push(attList);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {NodeList}\n\t\t */\n\t\tgetNodesByAttribute: function(node, attributeName) {\n\t\t\tvar selector = '[' + attributeName + ']';\n\t\t\treturn node.querySelectorAll(selector);\n\t\t},\n\n\n\t\t/**\n\t\t * gets all child nodes with a given attribute containing a given value\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} attributeName\n\t\t * @return {DOM NodeList}\n\t\t */\n\t\tgetNodesByAttributeValue: function(rootNode, name, value) {\n\t\t\tvar arr = [],\n\t\t\t\tx = 0,\n\t\t\t\ti,\n\t\t\t\tout = [];\n\n\t\t\tarr = this.getNodesByAttribute(rootNode, name);\n\t\t\tif(arr) {\n\t\t\t\ti = arr.length;\n\t\t\t\twhile(x < i) {\n\t\t\t\t\tif(this.hasAttributeValue(arr[x], name, value)) {\n\t\t\t\t\t\tout.push(arr[x]);\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * gets attribute value from controlled list of tags\n\t\t *\n\t\t * @param  {Array} tagNames\n\t\t * @param  {String} attributeName\n\t\t * @return {String || null}\n\t\t */\n\t\tgetAttrValFromTagList: function(node, tagNames, attributeName) {\n\t\t\tvar i = tagNames.length;\n\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\tvar attrValue = this.getAttribute(node, attributeName);\n\t\t\t\t\tif(attrValue && attrValue !== '') {\n\t\t\t\t\t\treturn attrValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\n\t   /**\n\t\t * get node if it has no siblings. CSS equivalent is :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendant: function(node){\n\t\t\treturn this.getDescendant( node, null, false );\n\t\t},\n\n\n        /**\n\t\t * get node if it has no siblings of the same type. CSS equivalent is :only-of-type\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetSingleDescendantOfType: function(node, tagNames){\n\t\t\treturn this.getDescendant( node, tagNames, true );\n\t\t},\n\n\n\t    /**\n\t\t * get child node limited by presence of siblings - either CSS :only-of-type or :only-child\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tgetDescendant: function( node, tagNames, onlyOfType ){\n\t\t\tvar i = node.children.length,\n\t\t\t\tcountAll = 0,\n\t\t\t\tcountOfType = 0,\n\t\t\t\tchild,\n\t\t\t\tout = null;\n\n\t\t\twhile(i--) {\n\t\t\t\tchild = node.children[i];\n\t\t\t\tif(child.nodeType === 1) {\n\t\t\t\t\tif(tagNames){\n\t\t\t\t\t\t// count just only-of-type\n\t\t\t\t\t\tif(this.hasTagName(child, tagNames)){\n\t\t\t\t\t\t\tout = child;\n\t\t\t\t\t\t\tcountOfType++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// count all elements\n\t\t\t\t\t\tout = child;\n\t\t\t\t\t\tcountAll++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(onlyOfType === true){\n\t\t\t\treturn (countOfType === 1)? out : null;\n\t\t\t}else{\n\t\t\t\treturn (countAll === 1)? out : null;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * is a node one of a list of tags\n\t\t *\n\t\t * @param  {DOM Node} rootNode\n\t\t * @param  {Array} tagNames\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTagName: function(node, tagNames){\n\t\t\tvar i = tagNames.length;\n\t\t\twhile(i--) {\n\t\t\t\tif(node.tagName.toLowerCase() === tagNames[i]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM appendChild\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node}\n\t\t */\n\t\tappendChild: function(node, childNode){\n\t\t\treturn node.appendChild(childNode);\n\t\t},\n\n\n\t   /**\n\t\t * abstracts DOM removeChild\n\t\t *\n\t\t * @param  {DOM Node} childNode\n\t\t * @return {DOM Node || null}\n\t\t */\n\t\tremoveChild: function(childNode){\n\t\t\tif (childNode.parentNode) {\n\t\t\t\treturn childNode.parentNode.removeChild(childNode);\n\t\t\t}else{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * abstracts DOM cloneNode\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {DOM Node}\n\t\t */\n\t\tclone: function(node) {\n\t\t\tvar newNode = node.cloneNode(true);\n\t\t\tif(this.hasAttribute(node, 'id')){\n\t\t\t\tthis.removeAttribute(node, 'id')\n\t\t\t}\n\t\t\treturn newNode;\n\t\t},\n\n\n\t\t/**\n\t\t * removes all the descendant tags by name\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {Array} tagNames\n\t\t * @return {DOM Node}\n\t\t */\n\t\tremoveDescendantsByTagName: function(node, tagNames) {\n\t\t\tfor (var i = 0; i < tagNames.length; i++) {\n\t\t\t\tif(node.getElementsByTagName){\n\t\t\t\t\tvar elements = node.getElementsByTagName(tagNames[i]);\n\t\t\t\t\twhile (elements[0]) {\n\t\t\t\t\t\telements[0].parentNode.removeChild(elements[0])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t},\n\n\n\t\t/**\n\t\t * gets the text of a node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tgetElementText: function( node ){\n\t\t\tif(node && node.data){\n\t\t\t\treturn node.data;\n\t\t\t}else{\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * gets the attributes of a node - ordered by sequence in html\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {Array}\n\t\t */\n\t\tgetOrderedAttributes: function( node ){\n\t\t\tvar nodeStr = node.outerHTML,\n\t\t\t\tattrs = [];\n\n\t\t\tfor (var i = 0; i < node.attributes.length; i++) {\n\t\t\t\tvar attr = node.attributes[i];\n\t\t\t\t\tattr.indexNum = nodeStr.indexOf(attr.name);\n\n\t\t\t\tattrs.push( attr );\n\t\t\t}\n\t\t\treturn attrs.sort( modules.utils.sortObjects( 'indexNum' ) );\n\t\t},\n\n\n\t\t/**\n\t\t * decodes html entities in given text\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  String} text\n\t\t * @return {String}\n\t\t */\n\t\tdecodeEntities: function( doc, text ){\n\t\t\t//return text;\n\t\t\treturn doc.createTextNode( text ).nodeValue;\n\t\t},\n\n\n\t\t/**\n\t\t * clones a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {DOM Document}\n\t\t */\n\t\tcloneDocument: function( document ){\n\t\t\tvar newNode,\n\t\t\t\tnewDocument = null;\n\n\t\t\tif( this.canCloneDocument( document )){\n\t\t\t\tnewDocument = document.implementation.createHTMLDocument('');\n\t\t\t\tnewNode = newDocument.importNode( document.documentElement, true );\n\t\t\t\tnewDocument.replaceChild(newNode, newDocument.querySelector('html'));\n\t\t\t}\n\t\t\treturn (newNode && newNode.nodeType && newNode.nodeType === 1)? newDocument : document;\n\t\t},\n\n\n\t\t/**\n\t\t * can environment clone a DOM document\n\t\t *\n\t\t * @param  {DOM Document} document\n\t\t * @return {Boolean}\n\t\t */\n\t\tcanCloneDocument: function( document ){\n\t\t\treturn (document && document.importNode && document.implementation && document.implementation.createHTMLDocument);\n\t\t},\n\n\n\t\t/**\n\t\t * get the child index of a node. Used to create a node path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Int}\n\t\t */\n\t\tgetChildIndex: function (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t  \t\ti = -1,\n\t\t  \t\tchild;\n\t  \t\twhile (parent && (child = parent.childNodes[++i])){\n\t\t\t\t if (child === node){\n\t\t\t\t\t return i;\n\t\t\t\t }\n\t\t\t}\n\t  \t\treturn -1;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @return {Array}\n\t\t */\n\t\tgetNodePath: function  (node) {\n\t\t  \tvar parent = node.parentNode,\n\t\t\t  \tpath = [],\n\t\t\t  \tindex = this.getChildIndex(node);\n\n\t\t  if(parent && (path = this.getNodePath(parent))){\n\t\t\t   if(index > -1){\n\t\t\t\t   path.push(index);\n\t\t\t   }\n\t\t  }\n\t\t  return path;\n\t\t},\n\n\n\t\t/**\n\t\t * get a node's path\n\t\t *\n\t\t *   @param  {DOM Node} node\n\t\t *   @param  {String} attributeName\n\t\t *   @return {String || null}\n\t\t */\n\t\tgetFirstAncestorAttribute: function  (node, attributeName) {\n\t\t\tif(!node){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(this.hasAttribute(node, attributeName)){\n\t\t\t\treturn this.getAttribute(node, attributeName);\n\t\t\t}else{\n\t\t\t\tvar parent = node.parentNode;\n\t\t\t\tif(parent){\n\t\t\t\t\treturn this.getFirstAncestorAttribute(parent, attributeName);\n\t\t\t\t}else{\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * get a node from a path.\n\t\t *\n\t\t *   @param  {DOM document} document\n\t\t *   @param  {Array} path\n\t\t *   @return {DOM Node}\n\t\t */\n\t\tgetNodeByPath: function (document, path) {\n\t\t  \tvar node = document.documentElement,\n\t\t  \t\ti = 0,\n\t\t  \t\tindex;\n\t\t  while ((index = path[++i]) > -1){\n\t\t\t  node = node.childNodes[index];\n\t\t  }\n\t\t  return node;\n\t\t},\n\n\n\t\t/**\n\t\t* get an array/nodeList of child nodes\n\t\t*\n\t\t*   @param  {DOM node} node\n\t\t*   @return {Array}\n\t\t*/\n\t\tgetChildren: function( node ){\n\t\t\treturn node.children;\n\t\t},\n\n\n\t\t/**\n\t\t* create a node\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNode: function( tagName ){\n\t\t\treturn this.document.createElement(tagName);\n\t\t},\n\n\n\t\t/**\n\t\t* create a node with text content\n\t\t*\n\t\t*   @param  {String} tagName\n\t\t*   @param  {String} text\n\t\t*   @return {DOM node}\n\t\t*/\n\t\tcreateNodeWithText: function( tagName, text ){\n\t\t\tvar node = this.document.createElement(tagName);\n\t\t\tnode.innerHTML = text;\n\t\t\treturn node;\n\t\t}\n\n\n\n\t};\n\n\n\tmodules.url = {\n\n\n\t\t/**\n\t\t * creates DOM objects needed to resolve URLs\n\t\t */\n        init: function(){\n            //this._domParser = new DOMParser();\n            this._domParser = modules.domUtils.getDOMParser();\n            // do not use a head tag it does not work with IE9\n            this._html = '<base id=\"base\" href=\"\"></base><a id=\"link\" href=\"\"></a>';\n            this._nodes = this._domParser.parseFromString( this._html, 'text/html' );\n            this._baseNode =  modules.domUtils.getElementById(this._nodes,'base');\n            this._linkNode =  modules.domUtils.getElementById(this._nodes,'link');\n        },\n\n\n\t\t/**\n\t\t * resolves url to absolute version using baseUrl\n\t\t *\n\t\t * @param  {String} url\n\t\t * @param  {String} baseUrl\n\t\t * @return {String}\n\t\t */\n\t\tresolve: function(url, baseUrl) {\n\t\t\t// use modern URL web API where we can\n\t\t\tif(modules.utils.isString(url) && modules.utils.isString(baseUrl) && url.indexOf('://') === -1){\n\t\t\t\t// this try catch is required as IE has an URL object but no constuctor support\n\t\t\t\t// http://glennjones.net/articles/the-problem-with-window-url\n\t\t\t\ttry {\n\t\t\t\t\tvar resolved = new URL(url, baseUrl).toString();\n\t\t\t\t\t// deal with early Webkit not throwing an error - for Safari\n\t\t\t\t\tif(resolved === '[object URL]'){\n\t\t\t\t\t\tresolved = URI.resolve(baseUrl, url);\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t}catch(e){\n                    // otherwise fallback to DOM\n                    if(this._domParser === undefined){\n                        this.init();\n                    }\n\n                    // do not use setAttribute it does not work with IE9\n                    this._baseNode.href = baseUrl;\n                    this._linkNode.href = url;\n\n                    // dont use getAttribute as it returns orginal value not resolved\n                    return this._linkNode.href;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(modules.utils.isString(url)){\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\t\t},\n\n\t};\n\n\n\t/**\n\t * constructor\n\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t *\n\t * @param  {String} dateString\n\t * @param  {String} format\n\t * @return {String}\n\t */\n\tmodules.ISODate = function ( dateString, format ) {\n\t\tthis.clear();\n\n\t\tthis.format = (format)? format : 'auto'; // auto or W3C or RFC3339 or HTML5\n\t\tthis.setFormatSep();\n\n\t\t// optional should be full iso date/time string\n\t\tif(arguments[0]) {\n\t\t\tthis.parse(dateString, this.format);\n\t\t}\n\t};\n\n\n\tmodules.ISODate.prototype = {\n\n\n\t\t/**\n\t\t * clear all states\n\t\t *\n\t\t */\n\t\tclear: function(){\n\t\t\tthis.clearDate();\n\t\t\tthis.clearTime();\n\t\t\tthis.clearTimeZone();\n\t\t\tthis.setAutoProfileState();\n\t\t},\n\n\n\t\t/**\n\t\t * clear date states\n\t\t *\n\t\t */\n\t\tclearDate: function(){\n\t\t\tthis.dY = -1;\n\t\t\tthis.dM = -1;\n\t\t\tthis.dD = -1;\n\t\t\tthis.dDDD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear time states\n\t\t *\n\t\t */\n\t\tclearTime: function(){\n\t\t\tthis.tH = -1;\n\t\t\tthis.tM = -1;\n\t\t\tthis.tS = -1;\n\t\t\tthis.tD = -1;\n\t\t},\n\n\n\t\t/**\n\t\t * clear timezone states\n\t\t *\n\t\t */\n\t\tclearTimeZone: function(){\n\t\t\tthis.tzH = -1;\n\t\t\tthis.tzM = -1;\n\t\t\tthis.tzPN = '+';\n\t\t\tthis.z = false;\n\t\t},\n\n\n\t\t/**\n\t\t * resets the auto profile state\n\t\t *\n\t\t */\n\t\tsetAutoProfileState: function(){\n\t\t\tthis.autoProfile = {\n\t\t\t   sep: 'T',\n\t\t\t   dsep: '-',\n\t\t\t   tsep: ':',\n\t\t\t   tzsep: ':',\n\t\t\t   tzZulu: 'Z'\n\t\t\t};\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find ISO date/time string i.e. 2008-05-01T15:45:19Z\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( dateString, format ) {\n\n\t\t\tthis.clear();\n\t\t\tthis.setFormat(format);\n\n\t\t\tvar parts = [],\n\t\t\t\ttzArray = [],\n\t\t\t\tposition = 0,\n\t\t\t\tdatePart = '',\n\t\t\t\ttimePart = '',\n\t\t\t\ttimeZonePart = '';\n\n\n\t\t\t// discover date time separtor for auto profile\n\t\t\t// Set to 'T' by default\n\t\t\tif(dateString.indexOf('t') > -1) {\n\t\t\t\tthis.autoProfile.sep = 't';\n\t\t\t}\n\t\t\tif(dateString.indexOf('z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'z';\n\t\t\t}\n\t\t\tif(dateString.indexOf('Z') > -1) {\n\t\t\t\tthis.autoProfile.tzZulu = 'Z';\n\t\t\t}\n\t\t\tif(dateString.toUpperCase().indexOf('T') === -1) {\n\t\t\t\tthis.autoProfile.sep = ' ';\n\t\t\t}\n\n\n\t\t\tdateString = dateString.toUpperCase().replace(' ','T');\n\n\t\t\t// break on 'T' divider or space\n\t\t\tif(dateString.indexOf('T') > -1) {\n\t\t\t\tparts = dateString.split('T');\n\t\t\t\tdatePart = parts[0];\n\t\t\t\ttimePart = parts[1];\n\n\t\t\t\t// zulu UTC\n\t\t\t\tif(timePart.indexOf( 'Z' ) > -1) {\n\t\t\t\t\tthis.z = true;\n\t\t\t\t}\n\n\t\t\t\t// timezone\n\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\ttzArray = timePart.split( 'Z' ); // incase of incorrect use of Z\n\t\t\t\t\ttimePart = tzArray[0];\n\t\t\t\t\ttimeZonePart = tzArray[1];\n\n\t\t\t\t\t// timezone\n\t\t\t\t\tif(timePart.indexOf( '+' ) > -1 || timePart.indexOf( '-' ) > -1) {\n\t\t\t\t\t\tposition = 0;\n\n\t\t\t\t\t\tif(timePart.indexOf( '+' ) > -1) {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '+' );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tposition = timePart.indexOf( '-' );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttimeZonePart = timePart.substring( position, timePart.length );\n\t\t\t\t\t\ttimePart = timePart.substring( 0, position );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tdatePart = dateString;\n\t\t\t}\n\n\t\t\tif(datePart !== '') {\n\t\t\t\tthis.parseDate( datePart );\n\t\t\t\tif(timePart !== '') {\n\t\t\t\t\tthis.parseTime( timePart );\n\t\t\t\t\tif(timeZonePart !== '') {\n\t\t\t\t\t\tthis.parseTimeZone( timeZonePart );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the date element of an ISO date/time string i.e. 2008-05-01\n\t\t *\n\t\t * @param  {String} dateString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseDate: function( dateString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearDate();\n\t\t\tvar parts = [];\n\n\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\tif(dateString.indexOf('-') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// YYYY-DDD\n\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)-(\\d\\d\\d)/ );\n\t\t\tif(parts) {\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dDDD = parts[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(this.dDDD === -1) {\n\t\t\t\t// YYYY-MM-DD ie 2008-05-01 and YYYYMMDD ie 20080501\n\t\t\t\tparts = dateString.match( /(\\d\\d\\d\\d)?-?(\\d\\d)?-?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.dY = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.dM = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.dD = parts[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.toString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. 13:30:45\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTime: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTime();\n\t\t\tvar parts = [];\n\n\t\t\t// discover date separtor for auto profile // default is ':'\n\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\tthis.autoProfile.tsep = '';\n\t\t\t}\n\n\t\t\t// finds timezone HH:MM:SS and HHMMSS  ie 13:30:45, 133045 and 13:30:45.0135\n\t\t\tparts = timeString.match( /(\\d\\d)?:?(\\d\\d)?:?(\\d\\d)?.?([0-9]+)?/ );\n\t\t\tif(parts[1]) {\n\t\t\t\tthis.tH = parts[1];\n\t\t\t}\n\t\t\tif(parts[2]) {\n\t\t\t\tthis.tM = parts[2];\n\t\t\t}\n\t\t\tif(parts[3]) {\n\t\t\t\tthis.tS = parts[3];\n\t\t\t}\n\t\t\tif(parts[4]) {\n\t\t\t\tthis.tD = parts[4];\n\t\t\t}\n\t\t\treturn this.toTimeString(this.format);\n\t\t},\n\n\n\t\t/**\n\t\t * parses text to find just the time element of an ISO date/time string i.e. +08:00\n\t\t *\n\t\t * @param  {String} timeString\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\tparseTimeZone: function( timeString, format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tthis.clearTimeZone();\n\t\t\tvar parts = [];\n\n\t\t\tif(timeString.toLowerCase() === 'z'){\n\t\t\t\tthis.z = true;\n\t\t\t\t// set case for z\n\t\t\t\tthis.autoProfile.tzZulu = (timeString === 'z')? 'z' : 'Z';\n\t\t\t}else{\n\n\t\t\t\t// discover timezone separtor for auto profile // default is ':'\n\t\t\t\tif(timeString.indexOf(':') === -1) {\n\t\t\t\t\tthis.autoProfile.tzsep = '';\n\t\t\t\t}\n\n\t\t\t\t// finds timezone +HH:MM and +HHMM  ie +13:30 and +1330\n\t\t\t\tparts = timeString.match( /([\\-\\+]{1})?(\\d\\d)?:?(\\d\\d)?/ );\n\t\t\t\tif(parts[1]) {\n\t\t\t\t\tthis.tzPN = parts[1];\n\t\t\t\t}\n\t\t\t\tif(parts[2]) {\n\t\t\t\t\tthis.tzH = parts[2];\n\t\t\t\t}\n\t\t\t\tif(parts[3]) {\n\t\t\t\t\tthis.tzM = parts[3];\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tthis.tzZulu = 'z';\n\t\t\treturn this.toTimeString( this.format );\n\t\t},\n\n\n\t\t/**\n\t\t * returns ISO date/time string in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar output = '';\n\n\t\t\tif(this.dY  > -1) {\n\t\t\t\toutput = this.dY;\n\t\t\t\tif(this.dM > 0 && this.dM < 13) {\n\t\t\t\t\toutput += this.dsep + this.dM;\n\t\t\t\t\tif(this.dD > 0 && this.dD < 32) {\n\t\t\t\t\t\toutput += this.dsep + this.dD;\n\t\t\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\t\t\toutput += this.sep + this.toTimeString( this.format );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(this.dDDD > -1) {\n\t\t\t\t\toutput += this.dsep + this.dDDD;\n\t\t\t\t}\n\t\t\t} else if(this.tH > -1) {\n\t\t\t\toutput += this.toTimeString( this.format );\n\t\t\t}\n\n\t\t\treturn output;\n\t\t},\n\n\n\t\t/**\n\t\t * returns just the time string element of an ISO date/time\n\t\t * in W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t * @return {String}\n\t\t */\n\t\ttoTimeString: function( format ) {\n\n\t\t\tthis.setFormat(format);\n\t\t\tvar out = '';\n\n\t\t\t// time can only be created with a full date\n\t\t\tif(this.tH) {\n\t\t\t\tif(this.tH > -1 && this.tH < 25) {\n\t\t\t\t\tout += this.tH;\n\t\t\t\t\tif(this.tM > -1 && this.tM < 61){\n\t\t\t\t\t\tout += this.tsep + this.tM;\n\t\t\t\t\t\tif(this.tS > -1 && this.tS < 61){\n\t\t\t\t\t\t\tout += this.tsep + this.tS;\n\t\t\t\t\t\t\tif(this.tD > -1){\n\t\t\t\t\t\t\t\tout += '.' + this.tD;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\t// time zone offset\n\t\t\t\t\tif(this.z) {\n\t\t\t\t\t\tout += this.tzZulu;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(this.tzH && this.tzH > -1 && this.tzH < 25) {\n\t\t\t\t\t\t\tout += this.tzPN + this.tzH;\n\t\t\t\t\t\t\tif(this.tzM > -1 && this.tzM < 61){\n\t\t\t\t\t\t\t\tout += this.tzsep + this.tzM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t * @param  {String} format\n\t\t */\n\t\tsetFormat: function( format ){\n\t\t\tif(format){\n\t\t\t\tthis.format = format;\n\t\t\t}\n\t\t\tthis.setFormatSep();\n\t\t},\n\n\n\t\t/**\n\t\t * set the current profile to W3C Note, RFC 3339, HTML5, or auto profile\n\t\t *\n\t\t */\n\t\tsetFormatSep: function() {\n\t\t\tswitch( this.format.toLowerCase() ) {\n\t\t\t\tcase 'microformat2':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'rfc3339':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '';\n\t\t\t\t\tthis.tsep = '';\n\t\t\t\t\tthis.tzsep = '';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w3c':\n\t\t\t\t\tthis.sep = 'T';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html5':\n\t\t\t\t\tthis.sep = ' ';\n\t\t\t\t\tthis.dsep = '-';\n\t\t\t\t\tthis.tsep = ':';\n\t\t\t\t\tthis.tzsep = ':';\n\t\t\t\t\tthis.tzZulu = 'Z';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// auto - defined by format of input string\n\t\t\t\t\tthis.sep = this.autoProfile.sep;\n\t\t\t\t\tthis.dsep = this.autoProfile.dsep;\n\t\t\t\t\tthis.tsep = this.autoProfile.tsep;\n\t\t\t\t\tthis.tzsep = this.autoProfile.tzsep;\n\t\t\t\t\tthis.tzZulu = this.autoProfile.tzZulu;\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a full date i.e. 2015-03-23\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasFullDate: function() {\n\t\t\treturn(this.dY !== -1 && this.dM !== -1 && this.dD !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum date which is just a year number i.e. 2015\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasDate: function() {\n\t\t\treturn(this.dY !== -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does current data contain a minimum time which is just a hour number i.e. 13\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTime: function() {\n\t\t\treturn(this.tH !== -1);\n\t\t},\n\n\t\t/**\n\t\t * does current data contain a minimum timezone i.e. -1 || +1 || z\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n\t\thasTimeZone: function() {\n\t\t\treturn(this.tzH !== -1);\n\t\t}\n\n\t};\n\n\tmodules.ISODate.prototype.constructor = modules.ISODate;\n\n\n\tmodules.dates = {\n\n\n\t\t/**\n\t\t * does text contain am\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasAM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('am') > -1 || text.indexOf('a.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * does text contain pm\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\thasPM: function( text ) {\n\t\t\ttext = text.toLowerCase();\n\t\t\treturn(text.indexOf('pm') > -1 || text.indexOf('p.m.') > -1);\n\t\t},\n\n\n\t\t/**\n\t\t * remove am and pm from text and return it\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tremoveAMPM: function( text ) {\n\t\t\treturn text.replace('pm', '').replace('p.m.', '').replace('am', '').replace('a.m.', '');\n\t\t},\n\n\n\t   /**\n\t\t * simple test of whether ISO date string is a duration  i.e.  PY17M or PW12\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisDuration: function( text ) {\n\t\t\tif(modules.utils.isString( text )){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\tif(modules.utils.startWith(text, 'p') ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t   /**\n\t\t * is text a time or timezone\n\t\t * i.e. HH-MM-SS or z+-HH-MM-SS 08:43 | 15:23:00:0567 | 10:34pm | 10:34 p.m. | +01:00:00 | -02:00 | z15:00 | 0843\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTime: function( text ) {\n\t\t\tif(modules.utils.isString(text)){\n\t\t\t\ttext = text.toLowerCase();\n\t\t\t\ttext = modules.utils.trim( text );\n\t\t\t\t// start with timezone char\n\t\t\t\tif( text.match(':') && ( modules.utils.startWith(text, 'z') || modules.utils.startWith(text, '-')  || modules.utils.startWith(text, '+') )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// has ante meridiem or post meridiem\n\t\t\t\tif( text.match(/^[0-9]/) &&\n\t\t\t\t\t( this.hasAM(text) || this.hasPM(text) )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// contains time delimiter but not datetime delimiter\n\t\t\t\tif( text.match(':') && !text.match(/t|\\s/) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t// if it's a number of 2, 4 or 6 chars\n\t\t\t\tif(modules.utils.isNumber(text)){\n\t\t\t\t\tif(text.length === 2 || text.length === 4 || text.length === 6){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\n\t\t/**\n\t\t * parses a time from text and returns 24hr time string\n\t\t * i.e. 5:34am = 05:34:00 and 1:52:04p.m. = 13:52:04\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tparseAmPmTime: function( text ) {\n\t\t\tvar out = text,\n\t\t\t\ttimes = [];\n\n\t\t\t// if the string has a text : or am or pm\n\t\t\tif(modules.utils.isString(out)) {\n\t\t\t\t//text = text.toLowerCase();\n\t\t\t\ttext = text.replace(/[ ]+/g, '');\n\n\t\t\t\tif(text.match(':') || this.hasAM(text) || this.hasPM(text)) {\n\n\t\t\t\t\tif(text.match(':')) {\n\t\t\t\t\t\ttimes = text.split(':');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// single number text i.e. 5pm\n\t\t\t\t\t\ttimes[0] = text;\n\t\t\t\t\t\ttimes[0] = this.removeAMPM(times[0]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// change pm hours to 24hr number\n\t\t\t\t\tif(this.hasPM(text)) {\n\t\t\t\t\t\tif(times[0] < 12) {\n\t\t\t\t\t\t\ttimes[0] = parseInt(times[0], 10) + 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add leading zero's where needed\n\t\t\t\t\tif(times[0] && times[0].length === 1) {\n\t\t\t\t\t\ttimes[0] = '0' + times[0];\n\t\t\t\t\t}\n\n\t\t\t\t\t// rejoin text elements together\n\t\t\t\t\tif(times[0]) {\n\t\t\t\t\t\ttext = times.join(':');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove am/pm strings\n\t\t\treturn this.removeAMPM(text);\n\t\t},\n\n\n\t   /**\n\t\t * overlays a time on a date to return the union of the two\n\t\t *\n\t\t * @param  {String} date\n\t\t * @param  {String} time\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tdateTimeUnion: function(date, time, format) {\n\t\t\tvar isodate = new modules.ISODate(date, format),\n\t\t\t\tisotime = new modules.ISODate();\n\n\t\t\tisotime.parseTime(this.parseAmPmTime(time), format);\n\t\t\tif(isodate.hasFullDate() && isotime.hasTime()) {\n\t\t\t\tisodate.tH = isotime.tH;\n\t\t\t\tisodate.tM = isotime.tM;\n\t\t\t\tisodate.tS = isotime.tS;\n\t\t\t\tisodate.tD = isotime.tD;\n\t\t\t\treturn isodate;\n\t\t\t} else {\n\t\t\t\tif(isodate.hasFullDate()){\n\t\t\t\t\treturn isodate;\n\t\t\t\t}\n\t\t\t\treturn new modules.ISODate();\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * concatenate an array of date and time text fragments to create an ISODate object\n\t\t * used for microformat value and value-title rules\n\t\t *\n\t\t * @param  {Array} arr ( Array of Strings )\n\t\t * @param  {String} format ( Modules.ISODate profile format )\n\t\t * @return {Object} Modules.ISODate\n\t\t */\n\t\tconcatFragments: function (arr, format) {\n\t\t\tvar out = new modules.ISODate(),\n\t\t\t\ti = 0,\n\t\t\t\tvalue = '';\n\n\t\t\t// if the fragment already contains a full date just return it once\n\t\t\tif(arr[0].toUpperCase().match('T')) {\n\t\t\t\treturn new modules.ISODate(arr[0], format);\n\t\t\t}else{\n\t\t\t\tfor(i = 0; i < arr.length; i++) {\n\t\t\t\t\tvalue = arr[i];\n\n\t\t\t\t\t// date pattern\n\t\t\t\t\tif( value.charAt(4) === '-' && out.hasFullDate() === false ){\n\t\t\t\t\t\tout.parseDate(value);\n\t\t\t\t\t}\n\n\t\t\t\t\t// time pattern\n\t\t\t\t\tif( (value.indexOf(':') > -1 || modules.utils.isNumber( this.parseAmPmTime(value) )) && out.hasTime() === false ) {\n\t\t\t\t\t\t// split time and timezone\n\t\t\t\t\t\tvar items = this.splitTimeAndZone(value);\n\t\t\t\t\t\tvalue = items[0];\n\n\t\t\t\t\t\t// parse any use of am/pm\n\t\t\t\t\t\tvalue = this.parseAmPmTime(value);\n\t\t\t\t\t\tout.parseTime(value);\n\n\t\t\t\t\t\t// parse any timezone\n\t\t\t\t\t\tif(items.length > 1){\n\t\t\t\t\t\t\tout.parseTimeZone(items[1], format);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// timezone pattern\n\t\t\t\t\tif(value.charAt(0) === '-' || value.charAt(0) === '+' || value.toUpperCase() === 'Z') {\n\t\t\t\t\t\tif( out.hasTimeZone() === false ){\n\t\t\t\t\t\t\tout.parseTimeZone(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\t// alway imply minutes\n\t\t\t\tif(out.tM === -1){\n\t\t\t\t\tout.tM = '00';\n\t\t\t\t}\n\t\t\t\treturn out;\n\t\t\t}\n\t\t},\n\n\n\t   /**\n\t\t * parses text by splitting it into an array of time and timezone strings\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {Array} Modules.ISODate\n\t\t */\n\t\tsplitTimeAndZone: function ( text ){\n\t\t   var out = [text],\n\t\t\t   chars = ['-','+','z','Z'],\n\t\t\t   i = chars.length;\n\n\t\t\twhile (i--) {\n\t\t\t  if(text.indexOf(chars[i]) > -1){\n\t\t\t\t  out[0] = text.slice( 0, text.indexOf(chars[i]) );\n\t\t\t\t  out.push( text.slice( text.indexOf(chars[i]) ) );\n\t\t\t\t  break;\n\t\t\t   }\n\t\t\t}\n\t\t   return out;\n\t\t}\n\n\t};\n\n\n\tmodules.text = {\n\n\t\t// normalised or whitespace or whitespacetrimmed\n\t\ttextFormat: 'whitespacetrimmed',\n\n\t\t// block level tags, used to add line returns\n\t\tblockLevelTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'hr', 'pre', 'table',\n\t\t\t'address', 'article', 'aside', 'blockquote', 'caption', 'col', 'colgroup', 'dd', 'div',\n\t\t\t'dt', 'dir', 'fieldset', 'figcaption', 'figure', 'footer', 'form',  'header', 'hgroup', 'hr',\n\t\t\t'li', 'map', 'menu', 'nav', 'optgroup', 'option', 'section', 'tbody', 'testarea',\n\t\t\t'tfoot', 'th', 'thead', 'tr', 'td', 'ul', 'ol', 'dl', 'details'],\n\n\t\t// tags to exclude\n\t\texcludeTags: ['noframe', 'noscript', 'template', 'script', 'style', 'frames', 'frameset'],\n\n\n\t\t/**\n\t\t * parses the text from the DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparse: function(doc, node, textFormat){\n\t\t\tvar out;\n\t\t\tthis.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t\tif(this.textFormat === 'normalised'){\n\t\t\t\tout = this.walkTreeForText( node );\n\t\t\t\tif(out !== undefined){\n\t\t\t\t\treturn this.normalise( doc, out );\n\t\t\t\t}else{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tvar clonedNode = modules.domUtils.clone(node);\n\t\t\t\tvar trimmedNode = modules.domUtils.removeDescendantsByTagName( clonedNode, this.excludeTags );\n\n\t\t\t   return this.formatText( doc, modules.domUtils.textContent(trimmedNode), this.textFormat );\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tparseText: function( doc, text, textFormat ){\n\t\t   var node = modules.domUtils.createNodeWithText( 'div', text );\n\t\t   return this.parse( doc, node, textFormat );\n\t\t},\n\n\n\t\t/**\n\t\t * parses the text from a html string - only for whitespace or whitespacetrimmed formats\n\t\t *\n\t\t * @param  {String} text\n\t\t * @param  {String} textFormat\n\t\t * @return {String}\n\t\t */\n\t\tformatText: function( doc, text, textFormat ){\n\t\t   this.textFormat = (textFormat)? textFormat : this.textFormat;\n\t\t   if(text){\n\t\t\t  var out = text\n\t\t\t  if(this.textFormat === 'whitespacetrimmed') {\n\t\t\t\t out = modules.utils.trimWhitespace( out );\n\t\t\t  }\n\t\t\t  return out;\n\t\t   }else{\n\t\t\t  return '';\n\t\t   }\n\t\t},\n\n\n\t\t/**\n\t\t * normalises whitespace in given text\n\t\t *\n\t\t * @param  {String} text\n\t\t * @return {String}\n\t\t */\n\t\tnormalise: function( doc, text ){\n\t\t\ttext = text.replace( /&nbsp;/g, ' ') ;    // exchanges html entity for space into space char\n\t\t\ttext = modules.utils.collapseWhiteSpace( text );     // removes linefeeds, tabs and addtional spaces\n\t\t\ttext = modules.domUtils.decodeEntities( doc, text );  // decode HTML entities\n\t\t\ttext = text.replace( '', '-' );          // correct dash decoding\n\t\t\treturn modules.utils.trim( text );\n\t\t},\n\n\n\t\t/**\n\t\t * walks DOM tree parsing the text from DOM Nodes\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForText: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\tif(node.tagName && this.excludeTags.indexOf( node.tagName.toLowerCase() ) > -1){\n\t\t\t\treturn out;\n\t\t\t}\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\tout += modules.domUtils.getElementText( node );\n\t\t\t}\n\n\t\t\t// get the text of the child nodes\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForText( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if it's a block level tag add an additional space at the end\n\t\t\tif(node.tagName && this.blockLevelTags.indexOf( node.tagName.toLowerCase() ) !== -1){\n\t\t\t\tout += ' ';\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out ;\n\t\t}\n\n\t};\n\n\n\tmodules.html = {\n\n\t\t// elements which are self-closing\n\t\tselfClosingElt: ['area', 'base', 'br', 'col', 'hr', 'img', 'input', 'link', 'meta', 'param', 'command', 'keygen', 'source'],\n\n\n\t\t/**\n\t\t * parse the html string from DOM Node\n\t\t *\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\tparse: function( node ){\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// we do not want the outer container\n\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\tout += text;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn out;\n\t\t},\n\n\n\t\t/**\n\t\t * walks the DOM tree parsing the html string from the nodes\n\t\t *\n\t\t * @param  {DOM Document} doc\n\t\t * @param  {DOM Node} node\n\t\t * @return {String}\n\t\t */\n\t\twalkTreeForHtml: function( node ) {\n\t\t\tvar out = '',\n\t\t\t\tj = 0;\n\n\t\t\t// if node is a text node get its text\n\t\t\tif(node.nodeType && node.nodeType === 3){\n\t\t\t\t//out += modules.domUtils.getElementText( node );\n\t\t\t\tvar containerNode = modules.domUtils.createNode('div');\n\t\t\t\tmodules.domUtils.appendChild(containerNode, modules.domUtils.clone(node));\n\t\t\t\tout += modules.domUtils.innerHTML(containerNode);\n\t\t\t}\n\n\n\t\t\t// exclude text which has been added with include pattern  -\n\t\t\tif(node.nodeType && node.nodeType === 1 && modules.domUtils.hasAttribute(node, 'data-include') === false){\n\n\t\t\t\t// begin tag\n\t\t\t\tout += '<' + node.tagName.toLowerCase();\n\n\t\t\t\t// add attributes\n\t\t\t\tvar attrs = modules.domUtils.getOrderedAttributes(node);\n\t\t\t\tfor (j = 0; j < attrs.length; j++) {\n\t\t\t\t\tout += ' ' + attrs[j].name +  '=' + '\"' + attrs[j].value + '\"';\n\t\t\t\t}\n\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) === -1){\n\t\t\t\t\tout += '>';\n\t\t\t\t}\n\n\t\t\t\t// get the text of the child nodes\n\t\t\t\tif(node.childNodes && node.childNodes.length > 0){\n\n\t\t\t\t\tfor (j = 0; j < node.childNodes.length; j++) {\n\t\t\t\t\t\tvar text = this.walkTreeForHtml( node.childNodes[j] );\n\t\t\t\t\t\tif(text !== undefined){\n\t\t\t\t\t\t\tout += text;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// end tag\n\t\t\t\tif(this.selfClosingElt.indexOf(node.tagName.toLowerCase()) > -1){\n\t\t\t\t\tout += ' />';\n\t\t\t\t}else{\n\t\t\t\t\tout += '</' + node.tagName.toLowerCase() + '>';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (out === '')? undefined : out;\n\t\t}\n\n\n\t};\n\n\n\tmodules.maps['h-adr'] = {\n\t\troot: 'adr',\n\t\tname: 'h-adr',\n\t\tproperties: {\n\t\t\t'post-office-box': {},\n\t\t\t'street-address': {},\n\t\t\t'extended-address': {},\n\t\t\t'locality': {},\n\t\t\t'region': {},\n\t\t\t'postal-code': {},\n\t\t\t'country-name': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-card'] =  {\n\t\troot: 'vcard',\n\t\tname: 'h-card',\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'adr': {\n\t\t\t\t'map': 'p-adr',\n\t\t\t\t'uf': ['h-adr']\n\t\t\t},\n\t\t\t'agent': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'bday': {\n\t\t\t\t'map': 'dt-bday'\n\t\t\t},\n\t\t\t'class': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'email': {\n\t\t\t\t'map': 'u-email'\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'key': {\n\t\t\t\t'map': 'u-key'\n\t\t\t},\n\t\t\t'label': {},\n\t\t\t'logo': {\n\t\t\t\t'map': 'u-logo'\n\t\t\t},\n\t\t\t'mailer': {},\n\t\t\t'honorific-prefix': {},\n\t\t\t'given-name': {},\n\t\t\t'additional-name': {},\n\t\t\t'family-name': {},\n\t\t\t'honorific-suffix': {},\n\t\t\t'nickname': {},\n\t\t\t'note': {}, // could be html i.e. e-note\n\t\t\t'org': {},\n\t\t\t'p-organization-name': {},\n\t\t\t'p-organization-unit': {},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t\t'rev': {\n\t\t\t\t'map': 'dt-rev'\n\t\t\t},\n\t\t\t'role': {},\n\t\t\t'sequence': {},\n\t\t\t'sort-string': {},\n\t\t\t'sound': {\n\t\t\t\t'map': 'u-sound'\n\t\t\t},\n\t\t\t'title': {\n\t\t\t\t'map': 'p-job-title'\n\t\t\t},\n\t\t\t'tel': {},\n\t\t\t'tz': {},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-entry'] = {\n\t\troot: 'hentry',\n\t\tname: 'h-entry',\n\t\tproperties: {\n\t\t\t'entry-title': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'entry-summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'entry-content': {\n\t\t\t\t'map': 'e-content'\n\t\t\t},\n\t\t\t'published': {\n\t\t\t\t'map': 'dt-published'\n\t\t\t},\n\t\t\t'updated': {\n\t\t\t\t'map': 'dt-updated'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'map': 'p-geo', \n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-event'] = {  \n\t\troot: 'vevent',\n\t\tname: 'h-event',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'dtstart': {\n\t\t\t\t'map': 'dt-start'\n\t\t\t},\n\t\t\t'dtend': {\n\t\t\t\t'map': 'dt-end'\n\t\t\t},\n\t\t\t'description': {},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'location': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'geo': {\n\t\t\t\t'uf': ['h-geo']\n\t\t\t},\n\t\t\t'latitude': {},\n\t\t\t'longitude': {},\n\t\t\t'duration': {\n\t\t\t\t'map': 'dt-duration'\n\t\t\t},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'organizer': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'attendee': {\n\t\t\t\t'uf': ['h-card']},\n\t\t\t'uid': {\n\t\t\t\t'map': 'u-uid'\n\t\t\t},\n\t\t\t'attach': {\n\t\t\t\t'map': 'u-attach'\n\t\t\t},\n\t\t\t'status': {},\n\t\t\t'rdate': {}, \n\t\t\t'rrule': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-feed'] = {\n\t\troot: 'hfeed',\n\t\tname: 'h-feed',\n\t\tproperties: {\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-summary'\n\t\t\t},\n\t\t\t'author': { \n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t},\n\t\t}\n\t};\n\n\n\tmodules.maps['h-geo'] = {\n\t\troot: 'geo',\n\t\tname: 'h-geo',\n\t\tproperties: {\n\t\t\t'latitude': {},\n\t\t\t'longitude': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-item'] = {\n\t\troot: 'item',\n\t\tname: 'h-item',\n\t\tsubTree: false,\n\t\tproperties: {\n\t\t\t'fn': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url'\n\t\t\t},\n\t\t\t'photo': {\n\t\t\t\t'map': 'u-photo'\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-listing'] = {\n\t\t\troot: 'hlisting',\n\t\t\tname: 'h-listing',\n\t\t\tproperties: {\n\t\t\t\t'version': {},\n\t\t\t\t'lister': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dtlisted': {\n\t\t\t\t\t'map': 'dt-listed'\n\t\t\t\t},\n\t\t\t\t'dtexpired': {\n\t\t\t\t\t'map': 'dt-expired'\n\t\t\t\t},\n\t\t\t\t'location': {},\n\t\t\t\t'price': {},\n\t\t\t\t'item': {\n\t\t\t\t\t'uf': ['h-card','a-adr','h-geo']\n\t\t\t\t},\n\t\t\t\t'summary': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'listing': {}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-news'] = {\n\t\t\troot: 'hnews',\n\t\t\tname: 'h-news',\n\t\t\tproperties: {\n\t\t\t\t'entry': {\n\t\t\t\t\t'uf': ['h-entry']\n\t\t\t\t},\n\t\t\t\t'geo': {\n\t\t\t\t\t'uf': ['h-geo']\n\t\t\t\t},\n\t\t\t\t'latitude': {},\n\t\t\t\t'longitude': {},\n\t\t\t\t'source-org': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'dateline': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'item-license': {\n\t\t\t\t\t'map': 'u-item-license'\n\t\t\t\t},\n\t\t\t\t'principles': {\n\t\t\t\t\t'map': 'u-principles', \n\t\t\t\t\t'relAlt': ['principles']\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-org'] = {\n\t\troot: 'h-x-org',  // drop this from v1 as it causes issue with fn org hcard pattern\n\t\tname: 'h-org',\n\t\tchildStructure: true,\n\t\tproperties: {\n\t\t\t'organization-name': {},\n\t\t\t'organization-unit': {}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-product'] = {\n\t\t\troot: 'hproduct',\n\t\t\tname: 'h-product',\n\t\t\tproperties: {\n\t\t\t\t'brand': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t\t'price': {},\n\t\t\t\t'description': {\n\t\t\t\t\t'map': 'e-description'\n\t\t\t\t},\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'url': {\n\t\t\t\t\t'map': 'u-url'\n\t\t\t\t},\n\t\t\t\t'review': {\n\t\t\t\t\t'uf': ['h-review', 'h-review-aggregate']\n\t\t\t\t},\n\t\t\t\t'listing': {\n\t\t\t\t\t'uf': ['h-listing']\n\t\t\t\t},\n\t\t\t\t'identifier': {\n\t\t\t\t\t'map': 'u-identifier'\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-recipe'] = {\n\t\t\troot: 'hrecipe',\n\t\t\tname: 'h-recipe',\n\t\t\tproperties: {\n\t\t\t\t'fn': {\n\t\t\t\t\t'map': 'p-name'\n\t\t\t\t},\n\t\t\t\t'ingredient': {\n\t\t\t\t\t'map': 'e-ingredient'\n\t\t\t\t},\n\t\t\t\t'yield': {},\n\t\t\t\t'instructions': {\n\t\t\t\t\t'map': 'e-instructions'\n\t\t\t\t},\n\t\t\t\t'duration': {\n\t\t\t\t\t'map': 'dt-duration'\n\t\t\t\t},\n\t\t\t\t'photo': {\n\t\t\t\t\t'map': 'u-photo'\n\t\t\t\t},\n\t\t\t\t'summary': {},\n\t\t\t\t'author': {\n\t\t\t\t\t'uf': ['h-card']\n\t\t\t\t},\n\t\t\t\t'published': {\n\t\t\t\t\t'map': 'dt-published'\n\t\t\t\t},\n\t\t\t\t'nutrition': {},\n\t\t\t\t'category': {\n\t\t\t\t\t'map': 'p-category',\n\t\t\t\t\t'relAlt': ['tag']\n\t\t\t\t},\n\t\t\t}\n\t\t};\n\n\n\tmodules.maps['h-resume'] = {\n\t\troot: 'hresume',\n\t\tname: 'h-resume',\n\t\tproperties: {\n\t\t\t'summary': {},\n\t\t\t'contact': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'education': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'experience': {\n\t\t\t\t'uf': ['h-card', 'h-event']\n\t\t\t},\n\t\t\t'skill': {},\n\t\t\t'affiliation': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review-aggregate'] = {\n\t\troot: 'hreview-aggregate',\n\t\tname: 'h-review-aggregate',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'average': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},       \n\t\t\t'count': {},\n\t\t\t'votes': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.maps['h-review'] = {\n\t\troot: 'hreview',\n\t\tname: 'h-review',\n\t\tproperties: {\n\t\t\t'summary': {\n\t\t\t\t'map': 'p-name'\n\t\t\t},\n\t\t\t'description': {\n\t\t\t\t'map': 'e-description'\n\t\t\t},\n\t\t\t'item': {\n\t\t\t\t'map': 'p-item',\n\t\t\t\t'uf': ['h-item', 'h-geo', 'h-adr', 'h-card', 'h-event', 'h-product']\n\t\t\t},\n\t\t\t'reviewer': {\n\t\t\t\t'uf': ['h-card']\n\t\t\t},\n\t\t\t'dtreviewer': {\n\t\t\t\t'map': 'dt-reviewer'\n\t\t\t},\n\t\t\t'rating': {},\n\t\t\t'best': {},\n\t\t\t'worst': {},\n\t\t\t'category': {\n\t\t\t\t'map': 'p-category',\n\t\t\t\t'relAlt': ['tag']\n\t\t\t},\n\t\t\t'url': {\n\t\t\t\t'map': 'u-url',\n\t\t\t\t'relAlt': ['self', 'bookmark']\n\t\t\t}\n\t\t}\n\t};\n\n\n\tmodules.rels = {\n\t\t// xfn\n\t\t'friend': [ 'yes','external'], \n\t\t'acquaintance': [ 'yes','external'],  \n\t\t'contact': [ 'yes','external'], \n\t\t'met': [ 'yes','external'], \n\t\t'co-worker': [ 'yes','external'],  \n\t\t'colleague': [ 'yes','external'], \n\t\t'co-resident': [ 'yes','external'],  \n\t\t'neighbor': [ 'yes','external'], \n\t\t'child': [ 'yes','external'],  \n\t\t'parent': [ 'yes','external'],  \n\t\t'sibling': [ 'yes','external'],  \n\t\t'spouse': [ 'yes','external'],  \n\t\t'kin': [ 'yes','external'], \n\t\t'muse': [ 'yes','external'],  \n\t\t'crush': [ 'yes','external'],  \n\t\t'date': [ 'yes','external'],  \n\t\t'sweetheart': [ 'yes','external'], \n\t\t'me': [ 'yes','external'], \n\t\n\t\t// other rel=* \n\t\t'license': [ 'yes','yes'],\n\t\t'nofollow': [ 'no','external'],\n\t\t'tag': [ 'no','yes'],\n\t\t'self': [ 'no','external'],\n\t\t'bookmark': [ 'no','external'],\n\t\t'author': [ 'no','external'],\n\t\t'home': [ 'no','external'],\n\t\t'directory': [ 'no','external'],\n\t\t'enclosure': [ 'no','external'],\n\t\t'pronunciation': [ 'no','external'],\n\t\t'payment': [ 'no','external'],\n\t\t'principles': [ 'no','external']\n\t\n\t};\n\n\n\n    var External = {\n        version: modules.version,\n        livingStandard: modules.livingStandard\n    };\n    \n    \n    External.get = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.get( options );\n    };\n    \n    \n    External.getParent = function(node, options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.getParent( node, options );\n    };\n    \n    \n    External.count = function(options){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.count( options );\n    };\n    \n    \n    External.isMicroformat = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.isMicroformat( node, options );\n    };\n    \n    \n    External.hasMicroformats = function( node, options ){\n    \tvar parser = new modules.Parser();\n        addV1(parser, options);\n    \treturn parser.hasMicroformats( node, options );\n    };\n    \n    \n    function addV1(parser, options){\n\t\tif(options && options.maps){\n\t\t\tif(Array.isArray(options.maps)){\n\t\t\t\tparser.add(options.maps);\n\t\t\t}else{\n\t\t\t\tparser.add([options.maps]);\n\t\t\t}\n\t\t}\n    }\n    \n    \n    return External;\n    \n    \n}));\n\n// Based on https://gist.github.com/1129031 By Eli Grey, http://eligrey.com - Public domain.\n\n// DO NOT use https://developer.mozilla.org/en-US/docs/Web/API/DOMParser example polyfill\n// as it does not work with earlier versions of Chrome\n\n\n(function(DOMParser) {var DOMParser_proto;\n    var real_parseFromString;\n    var textHTML;         // Flag for text/html support\n    var textXML;          // Flag for text/xml support\n    var htmlElInnerHTML;  // Flag for support for setting html element's innerHTML\n\n    // Stop here if DOMParser not defined\n    if (!DOMParser) {\n        return;\n    }\n\n    // Firefox, Opera and IE throw errors on unsupported types\n    try {\n        // WebKit returns null on unsupported types\n        textHTML = !!(new DOMParser()).parseFromString('', 'text/html');\n\n    } catch (er) {\n      textHTML = false;\n    }\n\n    // If text/html supported, don't need to do anything.\n    if (textHTML) {\n        return;\n    }\n\n    // Next try setting innerHTML of a created document\n    // IE 9 and lower will throw an error (can't set innerHTML of its HTML element)\n    try {\n      var doc = document.implementation.createHTMLDocument('');\n      doc.documentElement.innerHTML = '<title></title><div></div>';\n      htmlElInnerHTML = true;\n\n    } catch (er) {\n      htmlElInnerHTML = false;\n    }\n\n    // If if that failed, try text/xml\n    if (!htmlElInnerHTML) {\n\n        try {\n            textXML = !!(new DOMParser()).parseFromString('', 'text/xml');\n\n        } catch (er) {\n            textHTML = false;\n        }\n    }\n\n    // Mess with DOMParser.prototype (less than optimal...) if one of the above worked\n    // Assume can write to the prototype, if not, make this a stand alone function\n    if (DOMParser.prototype && (htmlElInnerHTML || textXML)) {\n        DOMParser_proto = DOMParser.prototype;\n        real_parseFromString = DOMParser_proto.parseFromString;\n\n        DOMParser_proto.parseFromString = function (markup, type) {\n\n            // Only do this if type is text/html\n            if (/^\\s*text\\/html\\s*(?:;|$)/i.test(type)) {\n                var doc, doc_el, first_el;\n\n                // Use innerHTML if supported\n                if (htmlElInnerHTML) {\n                    doc = document.implementation.createHTMLDocument('');\n                    doc_el = doc.documentElement;\n                    doc_el.innerHTML = markup;\n                    first_el = doc_el.firstElementChild;\n\n                // Otherwise use XML method\n                } else if (textXML) {\n\n                    // Make sure markup is wrapped in HTML tags\n                    // Should probably allow for a DOCTYPE\n                    if (!(/^<html.*html>$/i.test(markup))) {\n                        markup = '<html>' + markup + '<\\/html>';\n                    }\n                    doc = (new DOMParser()).parseFromString(markup, 'text/xml');\n                    doc_el = doc.documentElement;\n                    first_el = doc_el.firstElementChild;\n                }\n\n                // Is this an entire document or a fragment?\n                if (doc_el.childElementCount === 1 && first_el.localName.toLowerCase() === 'html') {\n                    doc.replaceChild(first_el, doc_el);\n                }\n\n                return doc;\n\n            // If not text/html, send as-is to host method\n            } else {\n                return real_parseFromString.apply(this, arguments);\n            }\n        };\n    }\n}(DOMParser));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/microformat-shiv/microformat-shiv.js\n// module id = 17\n// module chunks = 2","import {clearItem, removeHighlight, focusClickedEntry, getCurrentItemUrl} from './page/entry';\n\n(function () {\n\n  document.body.addEventListener('click', clearItem);\n\n  document.body.addEventListener('contextmenu', focusClickedEntry);\n\n  function handleMessage(request, sender, sendResponse) {\n    switch (request.action) {\n      case 'fetch-token-error':\n        handleTokenError(request.payload.error);\n        break;\n      // case 'remove-entry-highlight':\n      //   removeHighlight();\n      //   break;\n    }\n  }\n  chrome.runtime.onMessage.addListener(handleMessage);\n\n  if (!document.hidden) {\n    sendFocusMessage();\n  }\n  window.addEventListener('focus', sendFocusMessage);\n\n  function handleTokenError(error) {\n    if (!isAuthPage) {\n      return;\n    }\n\n    const heading = document.querySelector('.main > h1');\n    const paragraph = document.querySelector('.main > p');\n    heading.innerHTML = 'Error fetching token from token endpoint';\n    paragraph.innerHTML = error;\n  }\n\n  function isAuthPage() {\n    const l = document.location;\n    return (l.hostname === 'omnibear.com' && l.pathname === '/auth/success/');\n  }\n\n  function sendFocusMessage() {\n    chrome.runtime.sendMessage({\n      action: 'focus-window',\n      payload: {\n        selectedEntry: getCurrentItemUrl(),\n      },\n    });\n  }\n}());\n\n\n\n// WEBPACK FOOTER //\n// ./src/page.js","// TODO: replace this lib with a better mf parser, preferably\n// one that doesn't blow up while tests run in Node environment\nimport microformat from 'microformat-shiv';\nimport {getAncestorNode, getAncestorNodeByClass} from './dom';\n\n\nconst CLASS_NAME = '__omnibear-selected-item';\nlet currentItem;\nlet currentItemUrl;\n\nexport function clearItem() {\n  if (currentItem) {\n    chrome.runtime.sendMessage({\n      action: 'clear-entry',\n    });\n    removeHighlight();\n  }\n}\n\nexport function removeHighlight() {\n  if (currentItem) {\n    currentItem.classList.remove(CLASS_NAME);\n    currentItem = null;\n    currentItemUrl = null;\n  }\n}\n\nexport function focusClickedEntry(e) {\n  clearItem();\n  let entry;\n  if (document.location.hostname === 'twitter.com') {\n    entry = findTweet(e.target);\n  } else if (document.location.hostname === 'www.facebook.com') {\n    entry = findFacebookPost(e.target);\n  } else {\n    entry = findHEntry(e.target);\n  }\n\n  if (!entry) {\n    return;\n  }\n  chrome.runtime.sendMessage({\n    action: 'select-entry',\n    payload: { url: entry.url },\n  });\n  entry.element.classList.add(CLASS_NAME);\n  currentItem = entry.element;\n  currentItemUrl = entry.url;\n}\n\nfunction findTweet(el) {\n  const element = getAncestorNodeByClass(el, 'tweet');\n  if (!element) { return false; };\n  const url = `https://twitter.com${element.getAttribute('data-permalink-path')}`;\n  return { element, url };\n}\n\nfunction findFacebookPost(el) {\n  const element = getAncestorNode(el, (e) => {\n    return e.id.startsWith('hyperfeed_story_id_');\n  });\n  if (!element) { return false; }\n\n  let timestamp = element.getElementsByClassName('timestampContent')\n  if (timestamp && timestamp[0]) {\n    timestamp = timestamp[0];\n    while(timestamp.tagName != 'A' && timestamp.tagName != 'BODY') {\n      timestamp = timestamp.parentElement;\n    }\n\n    const url = timestamp.href;\n    if (url) {\n      return { element, url };\n    }\n  }\n\n  return {};\n}\n\nfunction findHEntry(el) {\n  const element = getAncestorNodeByClass(el, 'h-entry');\n  if (!element) { return false; }\n  const mf = microformat.get({node: el});\n  let url;\n  if (mf.items.length && mf.items[0].properties && mf.items[0].properties.url) {\n    url = mf.items[0].properties.url[0];\n  }\n\n  return { element, url };\n}\n\nexport function getCurrentItemUrl() {\n  return currentItemUrl;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/page/entry.js"],"sourceRoot":""}